[
  {
    "title": "숨바꼭질",
    "link": "https://velog.io/@gawgjiug/%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88",
    "description": "<p><a href=\"https://www.acmicpc.net/problem/13549\">13549번 : 숨바꼭질3</a></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/ca7a7d06-8a8d-4bb7-90d8-b4c17dc11c10/image.png\" alt=\"\"></p>\n<pre><code class=\"language-java\">package Gold_5;\n\nimport javax.xml.soap.Node;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class HideAndSeek {\n    //진행되는 연산은 3종류 +1,-1,*2 이다 이때 연산 순서도 중요함\n    static int min = Integer.MAX_VALUE;\n    static int n,k;\n    static boolean[] visited;\n    static int max = 100000; //수빈이가 이동할 수 있는 최대위치\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        k = sc.nextInt();\n\n        visited = new boolean[max+1]; //위치 범위는 0~10000\n        bfs();\n        System.out.println(min);\n\n\n    }\n\n    private static void bfs() {\n        Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();\n        q.offer(new Node(n,0)); //수빈이의 초기 위치와 시간(0)을 큐에 넣음\n        while(!q.isEmpty()) {\n            Node node = q.poll(); //현재위치를 node로 꺼내고 그 위치를 방문한 것으로 처리\n            visited[node.x] = true;\n            if(node.x == k) min = Math.min(min, node.time); //현재 위치가 동생의 위치 k와 같으면 최소시간 갱신\n\n            if(node.x * 2 &lt;= max &amp;&amp; visited[node.x * 2] == false) q.offer(new Node(node.x * 2, node.time));\n            if(node.x + 1 &lt;= max &amp;&amp; visited[node.x + 1] == false) q.offer(new Node(node.x + 1, node.time + 1));\n            if(node.x - 1 &gt;= 0 &amp;&amp; visited[node.x - 1] == false) q.offer(new Node(node.x - 1, node.time + 1));\n        }\n    }\n    public static class Node{\n        int x;\n        int time;\n        public Node(int x, int time){\n            this.x  = x;\n            this.time  = time;\n        }\n    }\n}</code></pre>\n<p>문제는 주어진 시작 위치 <code>n</code> 에서 동생의 위치 <code>k</code> 까지 이동하는 데 필요한 최소 시간을 계산하는 것이다.</p>\n<p>수빈이는 최대 100,000 까지의 위치로 이동할 수 있다. </p>\n<h3 id=\"접근-방식\">접근 방식</h3>\n<p>이 문제를 해결하기 위해 BFS(너비 우선 탐색) 알고리즘을 사용했다. BFS는 최단 경로 문제에 적합한 알고리즘으로 모든 가능한 위치를 탐색하며 최단 경로를 찾아내기 때문임.</p>\n<h3 id=\"코드-작동-방식\">코드 작동 방식</h3>\n<ol>\n<li><p>초기화 : 사용자의 입력을 받아 수빈이의 초기 위치 n과 동생의 위치를 설정 방문한 위치를 기록하기 위한 배열 <code>visited</code> 를 초기화함</p>\n</li>\n<li><p>BFS 실행: bfs 메서드에서 큐를 사용하여 수빈이의 위치와 경과 시간을 저장합니다. 큐에서 현재 위치를 꺼내고, 동생의 위치와 비교하여 최소 시간을 업데이트합니다.</p>\n</li>\n<li><p>이동 처리: 현재 위치에서 세 가지 이동 방법(두 배로 이동, +1 이동, -1 이동)을 모두 검사하고, 유효한 이동일 경우 큐에 추가합니다.</p>\n</li>\n<li><p>최종 결과 출력: 동생의 위치에 도달하는 최소 시간을 출력합니다.</p>\n</li>\n</ol>\n",
    "pubDate": "Fri, 11 Oct 2024 08:55:06 GMT",
    "thumbnail": null
  },
  {
    "title": "쿠키와 세션 개념",
    "link": "https://velog.io/@gawgjiug/%EC%BF%A0%ED%82%A4%EC%99%80-%EC%84%B8%EC%85%98-%EA%B0%9C%EB%85%90",
    "description": "<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/4116e816-5638-4019-88db-0c6875a70883/image.png\" alt=\"\"></p>\n<h4 id=\"http의-특징과-쿠키와-세션을-사용하는-이유\">HTTP의 특징과 쿠키와 세션을 사용하는 이유</h4>\n<ul>\n<li><p>쿠키와 세션을 사용하는 이유는 바로 HTTP 프로토콜의 특성이자 약점을 보완하기 위함이다</p>\n</li>\n<li><p>기본적으로 HTTP 프로토콜 환경은 <code>connectionless</code> <code>stateless</code> 한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 한다. </p>\n</li>\n<li><p>이러한 특성을 보완하기 위해서 쿠키와 세션을 사용하게 되는 것</p>\n</li>\n</ul>\n<blockquote>\n<p>connectionless 란?\n클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징을 말한다.\nHTTP 는 먼저 클라이언트가 request 를 서버에 보내면 , 서버는 클라이언트 요청에 맞는 response 를 보내고 접속을 끊는 특성이 있다.</p>\n</blockquote>\n<blockquote>\n<p>stateless 란?\n통신이 끝나면 상태를 유지하지 않는 특징을 말한다.\n연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있다.\n쿠키와 세션은 위의 두 가지 특징을 해결하기 위해 사용한다.</p>\n</blockquote>\n<blockquote>\n<p>HTTP? 란?\nHTTP(HyperText Transfer Protocol)는 월드 와이드 웹(WWW)에서 정보를 주고받기 위한 프로토콜이다. 쉽게 말해, 웹 브라우저와 서버가 인터넷을 통해 데이터를 주고받을 때 사용하는 규칙을 말하는데, 주로 웹 페이지(HTML), 이미지, 동영상, 파일 등의 데이터를 주고받는 데 사용된다.</p>\n</blockquote>\n<p>즉, 요청이 끝나면 서버는 유저가 누군지 잊어버리기 때문에, 요청 할 때마다. 우리가 누군지 <code>알려줘야</code> 한다는 것</p>\n<p>이를 하는 방법 중 하나가 <code>세션</code> 임 </p>\n<p>예를들어 <code>곽지욱</code> 이라는 유저가 있고 로그인 하고 싶다면 <code>유저명</code> 그리고 <code>비밀번호</code> 를 서버에 보내게 된다. </p>\n<p>비밀번호가 확인된다면 서버는 세션 DB에 <code>곽지욱</code> 이라는 유저를 생성한다 해당 세션에는 별도의 ID가 있고,</p>\n<p>해당 세션 ID는 쿠키를 통해 브라우저로 돌아오고 저장된다. 따라서 같은 웹 사이트의 다른 페이지로 이동하면 브라우저는 세션 ID를 갖고 있는 쿠키를 서버에게 보내게 된다.</p>\n<p>왜냐면 쿠키는 자동으로 보내지기 때문이다 </p>\n<p>서버는 들어오는 쿠키를 보고, 해당 세션 ID를 가지고 세션 DB를 확인할 것이고 거기서 해당 ID는 유저명 <code>곽지욱</code> 의 것이라는 것 알게되고. 그때 서버는 사용자를 구분할 수 있게 된다. </p>\n<p>이 작업이 끝나고 다른 페이지로 이동하게 되면 이 모든 프로세스가 반복되는 것</p>\n<p>여기서 중요한 건 모든 중요한 유저 데이터는 모두 서버에 있고 유저가 브라우저 상에서 갖고잇는 것은 세션 ID 뿐이라는 것이다.</p>\n<hr>\n<h4 id=\"쿠키cookie\">쿠키(Cookie)</h4>\n<ul>\n<li><p>쿠키란? 위에서 말했듯이 그저 세션 ID를 전달하기 위한 매개체일 뿐이다.</p>\n</li>\n<li><p>쿠키를 이용해서 서번는 나의 브라우저에 데이터를 넣을 수 있다.</p>\n</li>\n<li><p>사이트에 방문하면 브라우저는 서버에 <code>요청</code> 을 보내게 되는데, 서버는 이에 <code>response</code> (응답)을 할 것이고 , 그 <code>응답</code> 에는 모든 데이터와 내가 찾던 페이지 정보가 들어있다. </p>\n</li>\n<li><p>또한 그곳에는 브라우저에 저장하고자 하는 쿠키가 있을 수 있는 것이다.</p>\n</li>\n<li><p>이 쿠키는 내가 브라우저에 저장해두고 해당 웹 사이트에 방문할 때 마다 브라우저는 해당 쿠키도 요청과 함께 보내게 된다.</p>\n</li>\n<li><p>참고로 쿠키는 도메인에 따라 제한이 되는데, 이 말은 즉슨 유튜브가 준 쿠키는 유튜브 서버에만 보내지게 된다는 것이다.</p>\n</li>\n<li><p>그리고 쿠키는 유효기간을 가지고 있다. 유효기간에 따라 어떤 쿠키는 하루 혹은 한달 등.. 서버가 정한 기간에 따라 유효한 특징을 가지고 있다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"쿠키의-동작-방식-예시\">쿠키의 동작 방식 예시</h4>\n<p>그리고 쿠키는 인증 뿐만 아니라 여러가지 정보를 저장할 수 있는데, </p>\n<p>예를 들면 사용자가 웹 사이트 언어 설정을 바꾸면 서버는 쿠키를 브라우저에게 주고 사용자가 선택한 언어를 저장하게 된다.</p>\n<p>따라서 다음에 내가 해당 웹 사이트에 방문할 때 쿠키는 요청과 함께 서버로 보내지고 덕분에 서버는 쿠키가 기억해둔 언어설정의 페이지를 제공할 수 있는 것이다.</p>\n<hr>\n<h4 id=\"세션이란\">세션이란?</h4>\n<p>세션이란 이미 말했지만, 서버 측에서 사용자의 상태 정보를 관리하는 방식으로, 클라이언트와 서버 간의 지속적인 통신 상태를 유지하기 위해 사용된다. </p>\n<p>앞서 설명한 HTTP의 두 가지 특성으로 인해 서버는 클라이언트의 정보를 매번 새롭게 받아야 하는데,</p>\n<p>이를 해결하기 위해 서버가 클라이언트의 정보를 일정 시간 동안 저장하여, 각 요청에서 사용자를 식벽할 수 있도록 돕는 역할을 한다고 생각하면 된다.</p>\n<hr>\n<h4 id=\"세션의-동작-방식\">세션의 동작 방식</h4>\n<ol>\n<li><p>세션 생성 : 사용자가 웹에 로그인 하거나 중요한 작업을 수행할 때, 서버는 클라이언트의 정보를 서버 내부의 세션 저장소에 기록한다. </p>\n</li>\n<li><p>세션 ID 발급 : 서버는 클라이언트가 고유한 세션을 가질 수 있도록 세션 ID를 발급하고, 이 세션 ID는  클라이언트가 해당 서버에서 진행하는 활동을 식별하기 위한 고유 값이다. </p>\n</li>\n</ol>\n<p>세션 ID는 주로 쿠키에 담겨 클라이언트 측 브라우저에 저장된다.</p>\n<ol start=\"3\">\n<li><p>세션 유지: 클라이언트가 웹 사이트의 다른 페이지로 이동하거나 추가적인 요청을 보낼 때, 브라우저는 자동으로 쿠키게 저장된 세션 ID를 서버로 전달한다.</p>\n</li>\n<li><p>세션 종료 : 세션은 일정 시간이 지나면 만료되거나, 사용자가 로그아웃 하는 경우 명시적으로 삭제된다. </p>\n</li>\n</ol>\n",
    "pubDate": "Wed, 02 Oct 2024 07:45:20 GMT",
    "thumbnail": null
  },
  {
    "title": "SEO 와 시맨틱 마크업",
    "link": "https://velog.io/@gawgjiug/SEO-%EC%99%80-%EC%8B%9C%EB%A7%A8%ED%8B%B1-%EB%A7%88%ED%81%AC%EC%97%85",
    "description": "<p>최근에 <code>SEO</code> 그리고 <code>시맨틱 마크업</code> 에 대해 자주 이야기를 듣게되었다.</p>\n<p>우선 <code>SEO</code>가 무엇일까?</p>\n<h2 id=\"seo란\">SEO란?</h2>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/6bd09dc4-dedd-4f88-861d-a3b8bf5b58da/image.png\" alt=\"\"></p>\n<p>한국어로는 검색엔진 최적화, 영어로는 Search Engine Oprimization 을 줄여서 <code>SEO</code> 라고한다.</p>\n<p>한 마디로 <code>SEO</code> 는 웹사이트가 검색 엔진에서 더 잘 인식되고 순위가 높게 표시되도록 최적화 하는 과정을 말한다. 구글을 예로 들자면 검색 엔진은 웹 페이지의 콘텐츠를 <code>크롤링</code> 하고 이 정보를 기반으로 검색 결과를 노출시킨다.</p>\n<blockquote>\n<p>여기서 크롤링은 &#39;웹 상을 돌아다니면서 정보를 수집하는 행위&#39; 를 말한다.</p>\n</blockquote>\n<p>이때 <code>SEO</code>가 잘된 페이지는 검색 결과에서 상위에 노출되기 때문에 더 많은 사용자가 웹사이트를 방문하게 된다. 이로 인해 자연 검색(Natural Search) 트래픽이 증가하게 되는 것.</p>\n<h2 id=\"시맨틱-마크업이란\">시맨틱 마크업이란?</h2>\n<p>시맨틱 마크업은 Semantic(의미론적인) + Markup(HTML 태그로 문서를 작성하는 것) 의 합성어이다.</p>\n<p>즉,<code>시멘틱 마크업</code> 이란 의미론적인 HTML 태그를 작성하는 것이라고 할 수 있다. HTML 태그에는 각각의 의미가 존재한다. </p>\n<blockquote>\n<p>헤더/푸터에 header와 footer 사용\n메인 컨텐츠에 main과 section 사용\n내비게이션에 nav 사용</p>\n</blockquote>\n<p>이런식으로 각각 의미에 맞는 태그를 사용하는 것이다 흔한 말로 <code>div 떡칠</code> 을 하지않고 분명한 의미를 가진 태그들을 알맞게 사용하는 것이 중요하다는 것</p>\n<p>그리고 단순히 <code>SEO</code> 와 같은 성능 측면에서의 기대값이 존재하기 때문에 시멘틱 마크업을 해야한다가 아니라</p>\n<p><code>웹 접근성</code> 을 위해서도 필요한 작업이다. 웹 접근성은 장애인이나 노인 분들이 비장애인과 같이 웹 사이트에 접근하여 이해할 수 있도록 하는 것을 의미하는데, </p>\n<p>이때 스크린 리더라는 프로그램을 사용하게 된다. 이 때에도 시멘틱 태그를 사용하는 것이 스크린 리더의 활용에도 긍정적인 영향을 주기 때문에 </p>\n<p>본인이 웹 개발자라면 다양한 사용자 층에게 얼마나<code>포용적</code> 인 웹을 개발하였는지 보여주는 지표가 될 수 있다고 생각한다.</p>\n<h2 id=\"코드예시\">코드예시</h2>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/213a0f11-af28-4faf-be70-c9d4337a4563/image.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/3448e49f-a02a-4550-8cf6-a29eea012acd/image.png\" alt=\"\"></p>\n<p>만약 첫 번째 사진 처럼 모든 태그들이 div로 되어있다면 직관적으로 코드의 구조를 알아보기가 매우 힘들다.</p>\n<p>반면에 두 번째 사진처럼 시맨틱 태그들을 사용하였을 경우 확실히 코드가 구조적으로 명확해보이고 유지보수 측면에서도 장점을 가질 수 있다.</p>\n<blockquote>\n<p>웹 접근성과 SEO는 당연히..</p>\n</blockquote>\n<h2 id=\"시맨틱-마크업과-seo의-구체적인-영향\">시맨틱 마크업과 SEO의 구체적인 영향</h2>\n<ol>\n<li>시맨틱 태그를 사용하면 각 요소의 의미가 명확해져, 검색 엔진은 해당 페이지의 구조와 내용을 당연히 쉽게 파악할 수 있게 된다 </li>\n</ol>\n<p>구체적으로는 검색엔진이 웹사이트를 <code>크롤링</code> 할 때, SEO 요소를 평가해서 페이지의 <code>랭킹</code>을 결정하고 그것이 검색결과 상단 , 하단에 표시 되는 기준 중 하나가 된다.</p>\n<h4 id=\"검색-엔진이-페이지를-평가하는-과정\">검색 엔진이 페이지를 평가하는 과정:</h4>\n<ol>\n<li><p>크롤링 : 웹 페이지를 자동으로 탐색하고 분석하는 단계 이 과정에서 페이지의 컨텐츠 태그, 링크 구조 등을 수집함</p>\n</li>\n<li><p>색인 : 크롤링한 데이터를 바탕으로 각 페이지의 정보를 색인에 저장한다. 이때 페이지의 주제와 관련된 키워드, 메타 데이터, 콘텐츠 풍질 등을 바탕으로 페이지를 분류</p>\n</li>\n</ol>\n<blockquote>\n<p>색인 : 검색엔진의 데이터베이스</p>\n</blockquote>\n<ol start=\"3\">\n<li>랭킹 : 사용자가 특정 키워드로 검색했을 때, 검색엔진은 색인된 페이지들을 랭킹 알고리즘을 통해 순서를 정함 이 가정에서 <code>SEO</code> 요소들이 중요한 역할을 함 </li>\n</ol>\n<p>즉, 색인된 데이터 베이스에서 입력한 검색 쿼리와 가장 관련서이 높은 페이지를 찾아내서 보여주는 것</p>\n<pre><code class=\"language-css\">검색 엔진이 SEO 평가 시 고려하는 요소\n시맨틱 마크업, 메타 태그, 모바일 친화성, 키워드 최적화 ... 등등 \n</code></pre>\n<p>예를 들면 <code>&lt;article&gt;</code> 태그는 독립적인 콘텐츠 블록임을 나타내고, <code>&lt;h1&gt;</code> 은 주요 제목이라는 정보를 전달한다. 검색 엔진은 이 정보들을 기반으로 페이지의 주제와 중요성을 파악해 순위를 매긴다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/855b089b-77b8-414f-aa0b-ba332c8d3a4e/image.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>브라우저 개발자 도구에서 구조 가시성 증가 : 시맨틱 마크업을 사용하면 브라우저의 개발자 도구에서 HTML 요소의 의미와 구조를 쉽게 파악할 수 있음 즉, 디버깅과 유지보수를 간소화 할 수 있다는 것.</li>\n</ol>\n",
    "pubDate": "Thu, 26 Sep 2024 06:57:21 GMT",
    "thumbnail": null
  },
  {
    "title": "[Js] 가비지 컬렉션",
    "link": "https://velog.io/@gawgjiug/%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98",
    "description": "<h1 id=\"가비지-컬렉션\">가비지 컬렉션</h1>\n<p>자바스크립트에서 가비지 컬렉션은 사용하지 않는 메모리를 자동으로 회수하여 메모리 누수를 방지하는 기능을 말한다.</p>\n<p>자바스크립트는 개발자가 명시적으로 메모리를 할당하거나 해제하지 않는다. 필요하지 않게 된 객체를 자동으로 정리하는 방식으로 동작한다.</p>\n<p>이 과정을 가비지 컬렉터(Garbage Collector)가 수행한다.</p>\n<p>즉, 우리가 생성한 원시값, 객체, 함수 등 메모리를 차지 하는 모든 것들을 <code>쓸모가 없어지면</code> 찾아내 삭제하는 과정을 말한다.</p>\n<p>그러면 왜?? 굳이 삭제할까??</p>\n<blockquote>\n<p>가비지 컬렉터는 한정된 메모리 자원을 효율적으로 관리하기 위해 설계된 장치이다. 컴퓨터의 메모리는 유한하기 때문에 프로그램이 실행되면서 더 이상 필요하지 않은 데이터를 자동으로 정리하여 새로운 데이터의 공간을 확보하기 위함임</p>\n</blockquote>\n<p>그렇다면 그 <code>쓸모가 없어짐</code> 이라는 기준은 어떻게 생길까??</p>\n<h1 id=\"가비지-컬렉션-기준\">가비지 컬렉션 기준</h1>\n<p>자바스크립트는 도달 가능성(reachability) 이라는 개념을 사용해 메모리 관리를 수행한다. </p>\n<p>여기서 <code>도달 가능한</code> 값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미한다.\n그렇게 <code>도달 가능하다</code> 라고 판단 된 값은 메모리에서 삭제되지 않는다.</p>\n<ol>\n<li>아래의 소개되는 값들은 그 태생부터 <code>도달 가능</code> 하기 때문에 명백한 이유 없이는 삭제 되지 않는다.</li>\n</ol>\n<ul>\n<li>현재 함수의 지역 변수와 매개변수</li>\n</ul>\n<pre><code class=\"language-javascript\">function exampleFunction(param) {\n    // param은 매개변수\n    let localVar = &quot;지역 변수입니다.&quot;; // localVar는 지역 변수\n\n    console.log(param);  // 매개변수 참조 가능\n    console.log(localVar);  // 지역 변수 참조 가능\n}\n\nexampleFunction(&quot;매개변수 값&quot;);</code></pre>\n<blockquote>\n<p>즉 <strong>현재 실행 중인 함수의 지역 변수와 매개변수</strong> 는 함수가 실행되는 동안에는\n메모리에 남아 있고, 함수가 종료되면 더 이상 사용되지 않는 것으로 간주되어 가비지 컬렉터가 이를 처리할 수 있다. 그러나 함수가 실행 중인 동안에는 이 값들은 메모리에서 &quot;도달 가능&quot; 한 상태로 유지되어 삭제되지 않는다.</p>\n</blockquote>\n<hr>\n<ul>\n<li>중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수</li>\n</ul>\n<pre><code class=\"language-javascript\">function outerFunction(outerParam) {\n    let outerVar = &quot;외부 함수 변수&quot;;\n\n    function innerFunction(innerParam) {\n        let innerVar = &quot;내부 함수 변수&quot;;\n\n        // 외부 함수의 변수와 매개변수에 접근 가능\n        console.log(outerVar);  // &quot;외부 함수 변수&quot;\n        console.log(outerParam);  // 외부 함수의 매개변수 값 출력\n        console.log(innerVar);  // &quot;내부 함수 변수&quot;\n        console.log(innerParam);  // 내부 함수의 매개변수 값 출력\n    }\n\n    return innerFunction;\n}\n\nconst myFunction = outerFunction(&quot;외부 매개변수 값&quot;);\nmyFunction(&quot;내부 매개변수 값&quot;);</code></pre>\n<blockquote>\n<p>중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수 라는 문징은 <strong>중첩 함수</strong> 구조에서 내부 함수가 외부 함수의 변수와 매개변수에 접근 가능하다는 것을 의미한다.</p>\n</blockquote>\n<blockquote>\n<p>자바스크립트에서 함수는 렉시컬 스코프 규칙을 따르기 때문에, 내부 함수는 자신을 포함하는 외부 함수의 변수나 매개변수를 기억하고 사용할 수 있다.</p>\n</blockquote>\n<ul>\n<li><p>전역 변수</p>\n</li>\n<li><p>기타 루트(root) 값</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.</li>\n</ol>\n<p>전역 변수에 객체가 저장되어 있다고 가정해보자. 이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면, 프로퍼티가 참조하는 객체는 <code>도달 가능한 값</code> 이 된다. </p>\n<h3 id=\"예제\">예제</h3>\n<pre><code class=\"language-javascript\">let user ={\n    name : &#39;John&quot;\n}</code></pre>\n<p>이 코드에서 전역 변수 &quot;user&quot;는 <code>{name : John}</code> 이라는 객체를 참조한다. 이러한 상태를 <code>도달 가능한 상태</code> 라고한다.</p>\n<pre><code class=\"language-javascript\">user = null;</code></pre>\n<p>이제 <code>user</code> 더 이상 객체를 참조하지 않게 되고 결과적으로는 <code>{name : John}</code> 객체는 도달할 수 없는 상태가 되면서 가비지 컬렉터가 이를 인식하고 메모리에서 삭제 시킨다.</p>\n<hr>\n<h3 id=\"참조-두개-예제\">참조 두개 예제</h3>\n<p>그렇다면 한 객체를 여러 변수에서 참조하는 경우를 보자</p>\n<pre><code class=\"language-javascript\">let user = {\n    name: &quot;John&quot;\n};\n\nlet admin = user;  // user를 admin으로 복사</code></pre>\n<p>이제 user와 admin 두 변수가 같은 객체를 참조하고 있다. <code>user</code> 를 <code>null</code>로 설정해도, <code>admin</code> 이 여전히 <code>{name : John}</code> 객체를 참조하므로, 객체는 <code>도달 가능한 상태</code> 로 인식된다.</p>\n<p>이런 경우에는 두 전역변수의 참조를 모두 삭제해야 <code>{name : John}</code> 객체를 <code>도달 불가능</code> 상태로 만들 수 있다.</p>\n<pre><code class=\"language-javascript\">user = null;  // user의 참조를 삭제\nadmin = null; // admin의 참조를 삭제</code></pre>\n<h3 id=\"연결된-객체\">연결된 객체</h3>\n<p>더 복잡한 구조에서 객체들이 서로를 참조하는 경우를 보자 예를 들어 두 객체가 서로를 참조하는 관계를 생각해보자.</p>\n<pre><code class=\"language-javascript\">function marry(man, woman) {\n    woman.husband = man;\n    man.wife = woman;\n    return {\n        father: man,\n        mother: woman\n    };\n}\n\nlet family = marry({\n    name: &quot;John&quot;\n}, {\n    name: &quot;Ann&quot;\n});\n</code></pre>\n<p>이 예제 코드에서 <code>family</code> 객체는 <code>man</code> 과 <code>woman</code> 객체를 참조하고 있다. 그리고 또 <code>man</code>은 <code>woman</code> 을 <code>woman</code> 은 <code>man</code> 을 참조한다. </p>\n<p>즉 현재 모든 객체는 <code>도달 가능한</code> 상태이다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/38060711-c411-4aa2-8443-21ba81def1ee/image.png\" alt=\"\"></p>\n<pre><code class=\"language-javascript\">delete family.father;\ndelete family.mother.husband;</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/e0dd5fe1-ed23-4ae4-b0bd-d5e99eb21998/image.png\" alt=\"\"></p>\n<p>삭제한 두 개의 참조 중 하나만 지웠다면, 모든 객체는 여전히 <code>도달 가능한</code> 상태였겠지만, 참조 두개를 지우게 되면 John 으로 들어갈 수 있는 참조는 모두 사라져 John은 <code>도달 가능한</code> 상태에서 벗어나게 된다.</p>\n<p>왜냐하면 외부로 나가는 참조 <code>wife</code>는 <code>도달 가능성</code> 에 영향을 주지 못하기 때문이다. 모든 객체는 외부에서 자신에게 들어오는 참조만이 <code>도달 가능성</code> 에 영향을 준다.</p>\n<p>위 사진의 결과로 John은 이제 도달 가능한 상태가 아니기 때문에 메모리에서 제거된다.</p>\n<p><strong>가비지 컬렉션 후 메모리 구조</strong></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/9f84a5c1-2b35-4b34-b6e7-399aee4691a0/image.png\" alt=\"\"></p>\n<blockquote>\n<p>루트 객체는 자바스크립트 엔진에서 기본적으로 접근할 수 있는 최상위 참조 가능한 객체를 말한다 브라우저 환경에서는 <code>window</code> Node.js 환경에서는 <code>global</code> 객체를 말한다.</p>\n</blockquote>\n<blockquote>\n<p>전역 변수는 <strong>스크립트 전체에서 접근할 수 있는 변수</strong> 를 말한다. 즉, 전역 스코프에서 선언된 변수로 어디서든지 접근할 수 있는 것을 말한다.</p>\n</blockquote>\n<h3 id=\"도달할-수-없는-섬\">도달할 수 없는 섬</h3>\n<p>위 사진들 처럼 객체들은 연결되어 마치 하나의 독립 된 섬 같은 구조를 만든다. 그리고 이 섬에 도달할 방법이 없는 경우, <code>들어오는 참조가 없는 경우</code> 섬을 구성하는 객체 전부가 메모리에서 삭제되는 것이다.</p>\n<p>위 객체에서 <code>루트 객체</code> <code>family</code> 객체이다 정확하게 얘기하면 <strong>루트 객체의 속성에 해당하는 전역 변수로 선언된 것</strong> 즉, <code>family</code>는 <strong>전역 변수</strong>로 선언되어 있기 때문에 <code>window</code> 객체의 속성으로 간주된다.</p>\n<pre><code class=\"language-javascript\">family = null;</code></pre>\n<p>이렇게 루트 객체인 <code>family</code> 가 아무것도 참조하지 않도록 하였다. </p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/3ba6e34a-769e-4085-b07c-d7051a99f52f/image.png\" alt=\"\"></p>\n<p>그렇다면 메모리 구조는 다음과 같을 것이다.</p>\n<p>이 사진을 보면 가비지 컬렉션에서 <code>도달할 수 없는 섬</code> 예제는 <code>도달 가능성</code> 이라는 개념이 얼마나 중요한지 보여준다.</p>\n<p>John 과 Ann은 여전히 서로를 참조하고 있고, 두 객체 모두 외부에서 들어오는 참조를 갖고 있지만.</p>\n<p>앞서 말했 던 가비지 컬렉션의 기준인 <code>기타 루트(root) 값</code> 과 <code>루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값</code> 이라는 기준에 미치지 못하기 때문에 섬(객체) 전체가 도달할 수 없는 사태가 되고, 섬을 구성하는 객체 전부가 메모리에서 제거 되는 것이다.</p>\n<hr>\n<h2 id=\"요약\">요약</h2>\n<ul>\n<li><p><code>도달 가능한 객체</code> 는 메모리에서 삭제되지 않으며, 프로그램이 실행되는 동안 참조가 유지된다.</p>\n</li>\n<li><p><code>참조 삭제</code> 는 객체가 더 이상 도달할 수 없는 상태가 되도록 만든다.</p>\n</li>\n<li><p><code>객체 간의 참조</code> 는 복잡한 구조를 만들 수 있고, 이들 객체가 외부에서 참조되지 않으면 메모리에서 제거된다.</p>\n</li>\n</ul>\n<p><a href=\"https://ko.javascript.info/garbage-collection#ref-712\">출처: 모던 javascript 튜토리얼</a></p>\n",
    "pubDate": "Wed, 11 Sep 2024 06:22:36 GMT",
    "thumbnail": null
  },
  {
    "title": "JS What is Prototype?",
    "link": "https://velog.io/@gawgjiug/JS-What-is-Prototype",
    "description": "<h3 id=\"프로토타입-객체\">프로토타입 객체</h3>\n<p>Java C++ 과 같은 클래스 기반 객체지향 프로그래밍 언어와 달리 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다. 따라서 자바스크립트의 동작 원리를 이해하기 위해서는 프로토타입의 개념을 잘 이해하고 있어야 한다.</p>\n<p>클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체를 생성한다.</p>\n<p>하지만 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(Class-less)도 객체를 생성할 수 있다.</p>\n<p><strong>그래서 프로토타입이란?</strong> 자바스크립트에서 프로토타입이란 객체 지향 프로그래밍에서 상속 기능을 구현하는 방식 중 하나이다. 쉽게 말해, 객체의 부모 역할을 하는 다른 객체를 가리키는 링크라고 생각할 수 있다.</p>\n<p>이 프로토타입을 통해 객체들은 다른 객체로부터 속성이나 메서드를 상속받아 사용할 수 있다.</p>\n<p>객체를 생성할 때 자바스크립트는 해당 객체의 프로토타입을 자동으로 설정한다.</p>\n<pre><code class=\"language-javascript\">function parents() {\n  this.a = &#39;A&#39;;\n  this.b = &#39;B&#39;;\n}\n\nconsole.log(parents.prototype);\nconsole.log(parents);</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/8f7c6812-67c9-4212-9a8d-03db260e703e/image.png\" alt=\"\"></p>\n<p>위 사진을 보면 코드상에서 <code>parents</code> 객체에 prototype 이라는 속성을 선언한 적도 없는데 자동으로 prototype 이라는 객체를 가지고 있는 것을 볼 수 있다.</p>\n<p>이를 통해 자바스크립트의 모든 객체는 자신의 부모 역할을 하는 담당 객체인 <code>Prototype</code> 객체와 연결되어있고, </p>\n<p>객체를 선언함과 동시에 <code>Parents.prototype</code> 이라는 빈 Object 가 어딘가에 존재하고, Parents 함수로부터 생성 된 모든 자식 객체들은 언제든지 어딘가에 존재하는 <code>Parents.prototype</code> 에 들어있는 값들 모두 가져다 사용할 수 있다.</p>\n<p>예를 들어, 자바스크립트의 모든 배열은 Array.prototype 이라는 기본 프로토타입을 가지며, 이 프로토타입에는 배열 객체가 사용할 수 있는 다양한 메서드 <code>sort, push, pop</code> 가 정의되어 있다.</p>\n<pre><code class=\"language-javascript\">const arr = new Array(4, 2, 1, 10);\n//Array 객체의 자식인 arr 생성한 것과 마찬가지\n\narr.sort(); \n//arr.sort 메서드를 정의한적도 없는데 사용할 수 있는 이유?\n//부모 객체인 Array의 유전자인 prototype 객체에 정의되어 있기 때문에 자식인 arr도 사용할 수 있는 것.\n</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/d64ff1cc-bb5b-4b41-b832-ad21d71888e0/image.png\" alt=\"\"></p>\n<h3 id=\"프로토타입-체인\">프로토타입 체인</h3>\n<p>프로토타입 체인이란 자바스크립트에서 객체가 속성이나 메서드를 찾을 때 사용하는 검색 메커니즘이다. 객체에 해당 속성이나 메서드가 없으면 자바스크립트는 자동으로 프로토타입 체인을 따라가며, 부모 객체의 프로토타입을 검색한다. 이 체인을 따라 올라가면서 속성이나 메서드를 찾게되면 그 값을 반환하고, 최종적으로 찾지 못하면 <code>undefined</code> 를 반환한다.</p>\n<pre><code class=\"language-javascript\">function parents() {\n  this.a = &#39;A&#39;;\n  this.b = &#39;B&#39;;\n}\n\nparents.prototype.name = &#39;gwag&#39;;\n\nconst child = new parents();\n\nconsole.log(child.name);</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/915a456b-cc27-43d1-a9ee-0209362dd980/image.png\" alt=\"\"></p>\n<p>위 사진을 보면 코드상으로 child 객체에 사용자는 name 이라는 속성을 정의한 적이 없는데, name을 사용할 수 있는 것을 볼 수 있다.</p>\n<p>이 경우가 프로토타입 체인과 연관되어있는 것인데. JS는 내부적으로 해당 코드를 우선적으로 child 객체가 name이라는 데이터를 가지고 있는지 확인하고, 없다면 childe의 부모의 <code>유전자(prototype)</code> 을 검색하고 없다면 계속해서 부모의 부모를 찾는 방식으로 데이터를 검색하게 된다.</p>\n<p>이런식으로 Object의 속성이나 메서드를 찾을 때 사용하는 <code>메커니즘</code> 자체를 우리는 <code>Prototype Chain</code> 이라고 한다.</p>\n<p>이러한 개념을 이해하면 이어질 <code>프로토타입을 이용한 상속</code> 에 관련 된 개념도 쉽게 이해할 수 있다.</p>\n<h3 id=\"그렇다면-이러한-메커니즘을-가능하게-해주는-것은-무엇일까\">그렇다면 이러한 메커니즘을 가능하게 해주는 것은 무엇일까?</h3>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/11d6266f-e793-4375-bbd9-bc6de5051668/image.png\" alt=\"\"></p>\n<p>위 사진을 보게되면 우리가 함수를 정의하면, 함수만 생성되는 것이 아니라 자동으로 Prototype Object도 같이 생성이 된다고 앞서서 얘기했었는데, </p>\n<p>이렇게 생성 된 함수는 prototype 이라는 속성을 통해 Prototype Object 에 접근할 수 있게 된다. </p>\n<p>그리고 이러한 Prototype Object 는 앞서 말한 <code>프로토타입 체인</code> 메커니즘을 가능하게 만드는 <code>__proto__</code> 라는 속성을 기본으로 가지게 된다.</p>\n<p>여기서 <code>__proto__</code>  은 Prototype Link 라고도 불리는데, <code>__proto__</code>  속성은 모든 객체가 빠짐없이 가지고 있는 속성을 얘기하고, <code>__proto__</code>  는 객체가 생성될 때 조상이었던 함수의 Prototype Object를 가리키게 된다.</p>\n<p>그래서 우리가 위의 예제들 처럼 자식 객체들이 부모객체가 가지고 있는 유전자 즉, Prototype Object 안에 정의되어있는 모든 속성과 함수들을 사용할 수 있는 것이다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/e0fdef04-bccd-4814-903d-b031f30a05dd/image.png\" alt=\"\"></p>\n<pre><code class=\"language-javascript\">function parents() {\n  this.a = &#39;A&#39;;\n  this.b = &#39;B&#39;;\n}\n\nconst child = new parents();\n\nconsole.log(child.__proto__);</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/8ef8044a-2157-4c1d-b473-dfa42b1bdc29/image.png\" alt=\"\"></p>\n<p>그리고 추가적으로 <code>__proto__</code> 와 <code>prototype</code> 의 차이점에 대해 헷갈려하는 분들이 많은데, <code>prototype</code>은 생성자 함수의 속성이고 <code>__proto__</code> 는 객체 인스턴스의 속성이라는 점을 알고 있으면 프로토타입을 이해하는 데에 있어서 혼동을 겪지 않을 것이다.</p>\n<pre><code class=\"language-javascript\">\nfunction Person() {\n  this.name = &#39;John&#39;;\n}\n\nPerson.prototype.greet = function() {\n  console.log(&#39;Hello, &#39; + this.name);\n};\n\nconst person1 = new Person();\n\nconsole.log(person1.__proto__ === Person.prototype); // true</code></pre>\n<p>위 예제에서 person1 객체는 Person 함수로 생성된 것이며, person1.<strong>proto</strong>는 Person.prototype을 가리킵니다. 따라서 person1은 Person.prototype에 정의된 greet 메서드를 사용할 수 있습니다</p>\n<h3 id=\"요약\">요약</h3>\n<ul>\n<li>함수는 Prototype Object를 자동으로 생성합니다.</li>\n<li>이 Prototype Object는 <strong>prototype</strong>이라는 속성으로 함수와 연결되어 있습니다.</li>\n<li>객체 인스턴스는 생성자 함수의 <strong>prototype</strong>을 <strong>proto</strong> 속성을 통해 참조합니다.</li>\n</ul>\n<p>이 메커니즘을 통해 자바스크립트의 객체는 상속과 메서드 공유를 가능하게 합니다. prototype은 생성자 함수와 연결된 속성이고, <strong>proto</strong>는 생성된 객체가 부모 객체를 참조하는 링크 역할을 한다</p>\n",
    "pubDate": "Tue, 03 Sep 2024 05:39:02 GMT",
    "thumbnail": null
  },
  {
    "title": "JavaScript 비동기 프로그래밍 pt2 (async ,await, Promise , try-catch ,fetch",
    "link": "https://velog.io/@gawgjiug/JavaScript-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-pt2-async-await-Promise-try-catch",
    "description": "<p>앞서 비동기 프로그래밍 pt 1에서 다뤘듯이 JS는 기본적으로 싱글 스레드 언어로, 한 번에 한 가지 작업만 처리할 수 있다.</p>\n<p><a href=\"https://velog.io/@gawgjiug/JS-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB\">비동기 프로그래밍 pt1</a></p>\n<ul>\n<li>하지만 본문에서 다룰 네트워크 요청 같은 경우는 작업 시간이 오래 걸릴 수 있기 때문에 작업을 처리할 때 비동기 프로그래밍이 필요하다</li>\n</ul>\n<h3 id=\"1-promise\">1. Promise</h3>\n<p><code>Promise</code> 는 자바스크립트에서 비동기 작업의 결과를 나타내는 객체이다 <code>Promise</code> 는 네 가지 상태를 가질 수 있는데, </p>\n<ul>\n<li><p>Pending (대기 중) : 초기 상태, 아직 작업이 완료되지 않음.</p>\n</li>\n<li><p>Fulfilled(이행 됨) : 작업이 성공적으로 완료 됨.</p>\n</li>\n<li><p>Rejected(거부됨) : 작업이 실패함.</p>\n</li>\n<li><p>Settled(해결됨) : 작업이 완료된 상태 (성공 또는 실패)</p>\n</li>\n</ul>\n<p>이렇듯 Promise 는 주로 비동기 작업의 성공 또는 실패 결과를 처리할 때 사용된다.</p>\n<pre><code class=\"language-javascript\">\nconst fetchData = () =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      const success = true; // 성공했다고 가정\n      if (success) {\n        resolve(&quot;데이터를 성공적으로 가져왔습니다.&quot;);\n      } else {\n        reject(&quot;데이터를 가져오는 데 실패했습니다.&quot;);\n      }\n    }, 2000);\n  });\n};\n\nfetchData()\n  .then((result) =&gt; {\n    console.log(result); // 데이터 성공 메시지\n  })\n  .catch((error) =&gt; {\n    console.error(error); // 에러 메시지\n  });</code></pre>\n<ul>\n<li><p>위의 예제에서 <code>fetchData</code> 함수는 2초 후에 데이터를 성공적으로 가져왔음을 알리는 <code>resolve</code> 를 호출한다 <code>then</code> 블록에서 성공 메시지를 받고 <code>catch</code>  오류를 처리한다.</p>\n</li>\n<li><p>이처럼 then과 catch를 연달아 사용하는 것을 promise 체이닝이라고 표현함 Promise를 사용하지 않았다면 콜백지옥을 맛봤을 것</p>\n</li>\n</ul>\n<h3 id=\"2-async-와-await\">2. async 와 await</h3>\n<ul>\n<li><p><code>async</code> 와 <code>await</code> 는 JS에서 비동기 작업을 좀 더 간편하게 작성할 수 있게 해주는 문법을 말한다.</p>\n</li>\n<li><p><code>async</code> 키워는 함수 앞에 붙여서 그 함수가 항상 <code>Promise</code> 를 반환하도록 만든다. 함수 내부에서 명시적으로 <code>Promise</code>를 반환하지 않더라도 <code>async</code> 가 붙은 함수는 자동으로 Promise로 래핑된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">const fetchDataAsync = async () =&gt; {\n  try {\n    const response = await fetchData(); // fetchData()가 완료될 때까지 대기\n    console.log(response); // 성공 메시지\n  } catch (error) {\n    console.error(error); // 에러 메시지\n  }\n};\n\nfetchDataAsync();</code></pre>\n<ul>\n<li><p>await은 <code>async</code> 함수 내에서만 사용할 수 있는 키워드이다. <code>await</code> 키워드는 <code>Promise</code> 가 이행되거나 거부될 때 까지 함수를 일시 정지 시키고, 결과를 반환할 때 가지 기다린다.</p>\n</li>\n<li><p>await은 비동기 작업이 완료될 때까지 기다린 후 결과를 사용할 수 있게 해주어서 코드가 마치 동기적으로 실행되는 것처럼 보이게 하고 비동기 함수에 안정성을 높여준다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">async function fetchData() {\n  const result = await fetch(&#39;https://api.example.com/data&#39;);\n  return result.json();\n}\n</code></pre>\n<ul>\n<li><p>여기서 <code>fetch</code> 는 웹 API 중 하나로 네트워크를 통해 리소스를 가져오거나 서버와의 HTTP 요청을 보내는 데 사용되는 JS 함수이다. 주로 AJAX 요청을 대체하거나 비동기적으로 데이터를 가져오기 위해 사용된다.</p>\n</li>\n<li><p>기본적으로 fetch 함수를 사용하면 Promise 객체가 반환되며, 이 객체는 네트워크 요청이 완료될 때 까지 대기한다. fetch 가 반환하는 <code>Promise</code> 는 두 개의 후속 메서드를 가질 수 있다. \n<code>then</code> 과 <code>catch</code> 이다.</p>\n</li>\n<li><p>성공적인 요청은 .then() 블록으로 처리되고, 실패한 요청은 .catch() 블록에서 처리된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">fetch(url)\n  .then(response =&gt; {\n    if (!response.ok) {\n      throw new Error(&#39;네트워크 응답이 올바르지 않습니다.&#39;);\n    }\n    return response.json(); // JSON 형식의 응답 데이터를 파싱\n  })\n  .then(data =&gt; {\n    console.log(data); // 파싱된 데이터를 처리\n  })\n  .catch(error =&gt; {\n    console.error(&#39;Fetch 오류:&#39;, error); // 오류 처리\n  });</code></pre>\n<ul>\n<li><p>여기서 Promise는 네트워크 요청이 <code>성공적</code> 으로 완료된 경우에만 resolve 된다. </p>\n</li>\n<li><p>하지만 여기서 <code>성공적</code>이라는 의미는 네트워크 요청이 서버와의 연결이 제대로 이루어졌음을 의미할 뿐 HTTP 상태 코드가 200번대 인지 여부를 보장하지는 않는다.</p>\n</li>\n<li><p>예를 들어, 서버가 404 또는 500 상태코드를 반환해도 <code>fetch</code>는 여전히 Promise를 resolve 한다는 점을 기억하면 좋다.</p>\n</li>\n<li><p>그리고 여기서 .ok 의 의미는 HTTP 상태 코드가 200번대 (200~299) 의 값일 경우 true를 반환 하는 것을 말한다. 이를 통해 응답이 HTTP 레벨에서 실제로 성공적인지 확인할 수 있다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 02 Sep 2024 13:33:30 GMT",
    "thumbnail": null
  }
]