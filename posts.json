[
  {
    "title": "MSW 에 대해서 아시나요?",
    "link": "https://velog.io/@gawgjiug/MSW-%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%84%EC%8B%9C%EB%82%98%EC%9A%94",
    "description": "<p>최근에 데이터를 실제로 fetching 하기 전 <code>퍼블리싱 혹은 Mocking</code> 단계에서는 컴포넌트를 어떻게 설계해야할까? 에 대한 고민을 하다가 <code>MSW</code> 라이브러리에 대해서 알게되어서 글을 작성합니다.</p>\n<p>우선 가장 이상적인 프론트와 백엔드의 작업방식은 API 명세가 모두 나온 이후에 FE 개발자가 작업에 들어가는 것입니다. 하지만 현실적으로 그러기 어려운 상황에서는 MSW(Mock Service Worker)를 활용한 API<code>모킹</code> 전략을 이용할 수 있습니다.</p>\n<p>앞에서 말한대로, <code>API 모킹</code> 은 개발 초기 단계에서 백엔드 서비스가 준비되지 않았을 때 혹은 더 나아가서 통합테스트를 수행할 때 매우 중요한 역할을 합니다.</p>\n<p>왜냐하면 API 모킹을 통해 실제 백엔드 서비스 없이도 프론트엔드 애플리케이션의 동작을 시뮬레이션 할 수 있기 때문입니다.</p>\n<hr>\n<h3 id=\"msw-소개\">MSW 소개</h3>\n<p>리액트 환경에서의 MSW는 브라우저와 <code>Node.js</code> 환경에서 네트워크 요청을 <code>가로채고</code> 모킹할 수 있는 라이브러리입니다.</p>\n<p>정확히는 MSW를 사용하여 실제 네트워크 요청을 가로채고, 개발자가 정의한 응답으로 대체할 수 있는 것인데요 이를 이용하면 실제 백엔드 서버 없이도 API 요청과 응답을 시뮬레이션 할 수 있겠죠?</p>\n<p>그리고 <code>요청 지연</code> 이나 상태 코드 등을 설정할 수 있어서 실제 네트워크 요청과 유사한 환경에서 시뮬레이션을 할 수 있습니다.</p>\n<hr>\n<h3 id=\"msw-작동-방식\">MSW 작동 방식</h3>\n<p>MSW가 브라우저에서 동작하는 방식은 다음과 같습니다. 우선 MSW 라이브러리를 설치하면 브라우저에 Servie Worker 를 등록합니다. 이후에 브라우저에서 이루어지는 실제 네트워크 <code>요청</code> 들을 (fetch 로 보낸 네트워크 요청 등등) Service Worker 가 가로채게 됩니다.</p>\n<p>그리고 이 가로챈 요청을 복사해서 실제 서버가 아니라 클라이언트 사이드에 있는 MSW 라이브러리로 보낸 후에 등록된 핸들러를 통해서 모의 응답을 제공받습니다. 그리고 제공받은 모의응답을 브라우저에게 그대로 전달하게 되는 것입니다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/c30b6a57-354f-4bf1-8358-cd7634b62208/image.png\" alt=\"\"></p>\n<blockquote>\n<p>그래서 Service Worker가 뭔데?</p>\n</blockquote>\n<p>서비스 워커는 브라우저가 백그라운드에서 실행하는 스크립트를 말하고, 웹 서비스와 브라우저 및 네트워크 사이에서 <code>프록시 서버</code> 의 역할을 한다.</p>\n<hr>\n<h3 id=\"사용-방법\">사용 방법</h3>\n<ol>\n<li>설치</li>\n</ol>\n<pre><code>npm install msw --save-dev</code></pre><ol start=\"2\">\n<li>핸들러 정의</li>\n</ol>\n<pre><code class=\"language-javascript\">// src/mocks/handlers.js\nimport { rest } from &#39;msw&#39;; //rest 객체 가져오기 API ㅇ청을 모킹하기 위한 헬퍼 제공\n\nexport const handlers = [\n  rest.get(&#39;/api/user&#39;, (req, res, ctx) =&gt; { //res 응답 , ctx 응답내용 설정\n    return res(\n      ctx.status(200),\n      ctx.json({ id: 1, name: &#39;John Doe&#39; })\n    );\n  }),\n];</code></pre>\n<ol start=\"3\">\n<li>Service Worker 설정</li>\n</ol>\n<pre><code class=\"language-javascript\">// src/mocks/browser.js\nimport { setupWorker } from &#39;msw&#39;;\nimport { handlers } from &#39;./handlers&#39;;\n\nexport const worker = setupWorker(...handlers); //인스턴스 생성 및 요청 핸들러 정의</code></pre>\n<ol start=\"4\">\n<li>Worker 실행 </li>\n</ol>\n<p>어플리케이션이 실행 될 때 워커를 실행하는 코드를 추가</p>\n<pre><code class=\"language-javascript\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport App from &#39;./App&#39;\n\nif (process.env.NODE_ENV === &#39;development&#39;) {\n  const { worker } = require(&#39;./mocks/browser&#39;)\n  worker.start()\n}\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))</code></pre>\n<ol start=\"5\">\n<li>적용 확인</li>\n</ol>\n<pre><code>[MSW] Mocking enabled.</code></pre><p>어플리케이션을 다시 시작하고, 브라우저 콘솔에서 아래와 같은 메세지가 뜨면 모킹이 활성화 된 것이다.</p>\n<p>그리고 이제 클라이언트에서 요청을 보내게 되면</p>\n<pre><code class=\"language-javascript\">fetch(&#39;/api/user&#39;)\n  .then((response) =&gt; response.json())\n  .then((data) =&gt; console.log(data)); // { id: 1, name: &quot;John Doe&quot; }</code></pre>\n<pre><code>{ id: 1, name: &quot;John Doe&quot; }</code></pre><p>이렇게 정상적으로 데이터를 받아볼 수 있다.</p>\n<h3 id=\"마무리\">마무리</h3>\n<p>현재 진행 중인 프로젝트에 MSW를 도입해 개발을 하니깐 굉장히 편리하다고 느꼈기 때문에 공유하고 싶었습니다. 정해진 기간에 백엔드와 프론트엔드가 동시에 개발을 시작하는데 API가 준비되지 않은 상황에서 프론트 개발을 빠르게 할 수 있다는 점이 너무 크게 다가왔었고, </p>\n<p>백엔드 의존도를 많이 줄이고 독립적으로 작업할 수 있어서 오히려 테스트 시간을 더 많이 확보한다거나 리팩토링 기간을 더 길게 잡는다던가 하는 일정 조율이 가능해서 추천드립니다.</p>\n<p>그리고 특히 직접 네트워크 <code>응답 상태</code> 를 조절하면서 내가 원하는 화면 (성공 화면, 로딩 화면, 에러 화면) 을 효율적으로 개발할수 있었고 <code>req</code> 에 에러코드를 전달해서 디버깅도 가능합니다.</p>\n<p><a href=\"https://mswjs.io/\">참고</a></p>\n",
    "pubDate": "Thu, 21 Nov 2024 06:47:41 GMT",
    "thumbnail": null
  },
  {
    "title": "React Query Optimistic Updates",
    "link": "https://velog.io/@gawgjiug/React-Query-Optimistic-Updates",
    "description": "<h3 id=\"낙관적-업데이트\">낙관적 업데이트</h3>\n<p>낙관적 업데이트의 개념은 다음과 같다.</p>\n<ul>\n<li><p>데이터가 <code>실제 서버</code> 에 반영되기 전에 미리 UI에 반영하여 사용자 경험을 향상시키는 기법</p>\n</li>\n<li><p>사용자가 서버 응답을 기다리지 않고도 즉각적인 피드백을 받을 수 있게 해준다.</p>\n</li>\n</ul>\n<p>낙관적 업데이트의 주요 단계는 이렇다.</p>\n<p>우선 업데이트를 수행하기 전에 현재 상태를 저장해야한다. 서버 요청이 실패했을 경우 원래 상태로 롤백하기 위함이다.</p>\n<h4 id=\"어떻게\">어떻게?</h4>\n<p>낙관적 상태 업데이트의 과정은 이렇다. </p>\n<p><code>queryClient.setQueryData</code> 메서드를 사용해서 로컬상태를 즉시 업데이트 한다. </p>\n<ul>\n<li>이 작업 전에 <code>queryClient.cancleQueries</code> 메서드로 해당 쿼리에 대한 모든 활성 쿼리를 취소해줄 수 있다.</li>\n</ul>\n<p>바로 이 작업이 사용자가 변경 사항을 즉시 확인할 수 있도록 하는 것</p>\n<hr>\n<p>그 다음 실제 데이터를 전송한다. 이때 <code>mutate</code> 혹은 <code>mutateAsync</code> 메서드를 사용하는 것</p>\n<p>서버 요청이 성공하면, 서버로부터 받은 최신 데이터를 다시 상태에 반영한다. 이 작업은 <code>onSettled</code> 콜백 함수에서 수행. </p>\n<hr>\n<h3 id=\"예제-코드\">예제 코드</h3>\n<p>코드로 낙관적 업데이트를 알아보면 이렇다</p>\n<pre><code class=\"language-javascript\">import { useMutation, useQueryClient } from &#39;react-query&#39;;\n\nfunction MyComponent() {\n    const queryClient = useQueryClient();\n\n    // Mutation을 설정합니다\n    const { mutate } = useMutation(updateData, {\n        // 1. 낙관적 업데이트: 기존 상태 백업, 즉시 UI에 반영\n        onMutate: async (newData) =&gt; {\n            await queryClient.cancelQueries(&#39;myData&#39;); // 활성 쿼리 취소\n\n            // (1) 기존 상태를 백업\n            const previousData = queryClient.getQueryData(&#39;myData&#39;); // 현재 상태를 백업\n\n            // (2) UI에 즉시 반영\n            queryClient.setQueryData(&#39;myData&#39;, (oldData) =&gt; {\n                return { ...oldData, ...newData }; // 새 데이터를 UI에 반영\n            });\n\n            // (3) 이전 상태 반환 (onError에서 롤백 시 사용)\n            return { previousData }; // 이후의 onError 등에서 복원할 수 있도록 반환\n        },\n\n        // 2. 서버 요청 실패 시 백업한 상태로 롤백\n        onError: (error, newData, context) =&gt; {\n            queryClient.setQueryData(&#39;myData&#39;, context.previousData); // 이전 상태로 복원\n        },\n\n        // 3. 서버 응답 시 최신 데이터로 상태 갱신\n        onSettled: () =&gt; {\n            queryClient.invalidateQueries(&#39;myData&#39;); // 데이터를 다시 가져와 최신 상태로 유지\n        },\n    });\n\n    return (\n        &lt;button onClick={() =&gt; mutate({ key: &#39;value&#39; })}&gt;\n            Update Data\n        &lt;/button&gt;\n    );\n}</code></pre>\n<p>onMutate 함수는 서버에 요청을 보내기 직전에 실행되며, 서버 요청이 실패했을 때는 UI 상태를 복원하는 동작을 수행한다.</p>\n<blockquote>\n<pre><code>       await queryClient.cancelQueries(&#39;myData&#39;); // 활성 쿼리 취소</code></pre></blockquote>\n<p>먼저 활성 쿼리를 취소해주는 작업은 <code>정확성</code> 을 보장하기 위해 존재한다.</p>\n<p>예를 들어 백엔드에서 데이터를 다시 가져오는 쿼리가 활성화 되어있다면, 서버 응답 시에 이전 데이터로 덮어 쓰는 문제가 발생할 수 있다</p>\n<p>더 자세하게는 사용자가 UI 에서 데이터를 업데이트하자마자 백엔드에서 이전 데이터를 불러오는 쿼리가 완료되면 업데이트된 UI가 갑자기 예전 상태로 돌아가 보일 수 있다.</p>\n<hr>\n<h3 id=\"활성-쿼리-취소\">활성 쿼리 취소</h3>\n<p>활성 쿼리 취소가 <code>왜?</code> 필요한지에 대해서 더 자세히 설명해보겠다. </p>\n<p>예를 들어 게시글 페이지에서 댓글 리스트가 표시되고, 각 댓글에는 좋아요 버튼이 존재한다고 가정해보자.</p>\n<p>사용자가 댓글에 좋아요를 누르면 해당 댓글의 좋아요 수가 UI에 즉시 반영되도록 낙관적 업데이트를 적용했다</p>\n<p>동시에 이 페이지에는 일정 주기로 백엔드에서 <code>최신 댓글 데이터를 가져오는 쿼리</code> <code>fetchComment</code> 가 활성화 되어있었는데,</p>\n<p>사용자가 좋아요 버튼을 클릭했을 때 낙관적 업데이트로 즉시 반영된 상태에서, 동시에 <code>fetchComment</code> 쿼리가 백엔드에서 이전의 댓글 리스트 데이터를 받아와 UI를 덮어 써버린다. </p>\n<p>위와 같은 현상을 방지하기 위해서 업데이트를 적용하기 전에 <code>cancleQueries</code> 를 호출해서 <code>fetchComment</code> 쿼리를 일시적으로 취소하는 것.</p>\n",
    "pubDate": "Mon, 11 Nov 2024 14:21:50 GMT",
    "thumbnail": null
  },
  {
    "title": "리액트 useParams 와 Query String",
    "link": "https://velog.io/@gawgjiug/%EB%A6%AC%EC%95%A1%ED%8A%B8-useParams-%EC%99%80-Query-String",
    "description": "<h3 id=\"useparams-란\">useParams() 란??</h3>\n<hr>\n<p>리액트에서 라우터 사용 시에 useParams 훅을 사용해서 url 의 <code>동적인</code> 파라미터 정보를 가져올 수 있다. 여기서 말하는 동적인 파라미터란? <code>url</code> 구조에서 <code>...url/path/1</code> 에서 이 1이 파라미터가 되는 것이다.</p>\n<pre><code>{\n  path: &quot;/post/:postId&quot;,\n  element: &lt;PostDetail /&gt;,\n},</code></pre><pre><code>function UserProfile() {\n  const { postId } = useParams(); // 현재 URL에서 postId 값을 가져옴\n}</code></pre><p>리액트의 useParams 훅으로 게시글 ID에 따라 다른 URL로 이동하는 예제로 이해해보자.</p>\n<p>우선 라이브러리를 설치해주고,</p>\n<p>라우터를 설정해준다.</p>\n<pre><code class=\"language-javascript\">// App.js\nimport React from &#39;react&#39;;\nimport { BrowserRouter as Router, Route, Routes } from &#39;react-router-dom&#39;;\nimport PostList from &#39;./PostList&#39;;\nimport PostDetail from &#39;./PostDetail&#39;;\n\nfunction App() {\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route path=&quot;/&quot; element={&lt;PostList /&gt;} /&gt;\n        &lt;Route path=&quot;/post/:id&quot; element={&lt;PostDetail /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/Router&gt;\n  );\n}\n\nexport default App;</code></pre>\n<hr>\n<pre><code class=\"language-javascript\">// PostList.js\nimport React from &#39;react&#39;;\nimport { Link } from &#39;react-router-dom&#39;;\n\nfunction PostList() {\n  const posts = [\n    { id: 1, title: &#39;게시글 1&#39; },\n    { id: 2, title: &#39;게시글 2&#39; },\n    { id: 3, title: &#39;게시글 3&#39; },\n  ];\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;게시글 목록&lt;/h1&gt;\n      &lt;ul&gt;\n        {posts.map((post) =&gt; (\n          &lt;li key={post.id}&gt;\n            &lt;Link to={`/post/${post.id}`}&gt;{post.title}&lt;/Link&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default PostList;</code></pre>\n<hr>\n<pre><code class=\"language-javascript\">// PostDetail.js\nimport React from &#39;react&#39;;\nimport { useParams } from &#39;react-router-dom&#39;;\n\nfunction PostDetail() {\n  const { id } = useParams();\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;게시글 상세 페이지&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default PostDetail;</code></pre>\n<h3 id=\"쿼리-스트링\">쿼리 스트링</h3>\n<p>쿼리스트링은? URL 의 한 부분이며, 요청하고자 하는 URL에 부가적인 정보를 포함하고 싶을 때 사용한다.</p>\n<p>기존 URL 요청 예시</p>\n<blockquote>\n<p>FE : /list - 리스트 요청\n     /detail - 상세 페이지 요청\nBE : /product - 단일 상품 응답\n     /products - 상품 들 응</p>\n</blockquote>\n<p>만약 상품의 종류가 많아질 경우 /list 페이지에서 모든 상품을 보여주는 것은 비효율적이다.</p>\n<p>예를 들어 1억개의 상품 정보를 모두 불러오는 것도, 비효율적이지만 유저는 판매량이나 최신순 같은 기준을 두고 정렬된 데이터를 보고싶어하는 경우가 일반적이기 때문이다.</p>\n<p>이런 상황에서 FE는 <code>상품 리스트 보여줘 + 최신순 10개</code> 와 같이 구체적인 요청을 할 수 있어야 한다.</p>\n<h4 id=\"쿼리스트링의-형태\">쿼리스트링의 형태</h4>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/99884c4c-74bc-4225-b044-97913bafc707/image.png\" alt=\"\"></p>\n<p>쿼리스트링은 이름 그대로 문자열 타입이며 key = value 로 표현된다. 또한 URL의 일부로 쿼리스트링의 시작점은 <code>?</code> 으로 표시된다.</p>\n<pre><code>&lt;Link to=&quot;/list?sort=popular&quot; /&gt;\n\nnavigate(&quot;/list?sort=popular&quot;)</code></pre><p>쿼리스트링을 포함해서 Routing 하는 방법은 간단히 Link 나 navigate를 이용하면 된다.</p>\n<h4 id=\"페이지네이션\">페이지네이션</h4>\n<p>페이지네이션?</p>\n<p>페이지네이션은 전체 데이터를 페이지 별로 분리해서 보여주는 UI다 페이지네이션을 구현하기 위해선 <code>offset</code> <code>limit</code> 이라는 두 가지 기준이 필요한데, offset 은 몇 번째 아이템 부터 보여줄 것인가. 를 말하는 것이고</p>\n<p>limit 은 한 번에 몇 개를 보여줄 것인가를 말하는 것이다. </p>\n<p>예를들어 페이지당 10개의 아이템을 보여주는 UI를 구현하고 싶다면 </p>\n<p>1페이지 - 0번째 이후 10개 아이템 보여줘 <code>offset = 0번째 이후</code> <code>limit = 10</code> 이 되는 것</p>\n<p><code>?offset=0&amp;limit=10</code> </p>\n<p>물론 프로젝트 마다 offset 이 start 라던지 limit 이 size 라던지 용어는 변경될 수 있다.</p>\n<h4 id=\"구현\">구현</h4>\n<ol>\n<li>URL 정보를 <code>useSearchParams()</code> 훅을 이용해서 가져온다</li>\n<li><code>offset</code> 과 <code>limit</code> 변수에 값을 저장해준다.</li>\n<li>fetch에 백엔드 API 호출하는 offset 과 limit  값으로 위 두 변수 값을 넣어준다.</li>\n<li>불러온 값을 posts state에 저장한다.</li>\n<li>posts 데이터를 이용해서 map 리렌더링</li>\n</ol>\n<p>이 부분은 백엔드와의 협업도 필요한데, 예를 들면 API를 설계할 때 프론트에서 offset 과 limit 값을 설정해서 get 요청을 날릴 것이니, 백엔드에서도 그것을 감안해서 범위에 맞는 데이터만 반환하도록 쿼리를 작성해야한다.</p>\n<pre><code class=\"language-sql\">SELECT * FROM posts LIMIT :limit OFFSET :offset;</code></pre>\n<p>프론트엔드에서는 페이지네이션을 구현하기 위해 현재 페이지 상태를 관리해야한다. 이때 offset 과 limit은 useState를 통해 관리할 수 있다.</p>\n<pre><code class=\"language-javascript\">const [posts, setPosts] = useState([]);\nconst [total, setTotal] = useState(0);\nconst [currentPage, setCurrentPage] = useState(1);\nconst limit = 10;\n\nuseEffect(() =&gt; {\n    const offset = (currentPage - 1) * limit;\n    fetch(`/api/posts?offset=${offset}&amp;limit=${limit}`)\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            setPosts(data.data);\n            setTotal(data.total);\n        });\n}, [currentPage]);</code></pre>\n",
    "pubDate": "Mon, 11 Nov 2024 11:56:13 GMT",
    "thumbnail": null
  },
  {
    "title": "TypeScript 동작원리",
    "link": "https://velog.io/@gawgjiug/TypeScript-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC",
    "description": "<p>모두가 컴퓨터는 인간과는 달리 바이트코드나 기계어, 이진수 같은 단순한 형태의 언어를 기반으로 동작한다는 사실을 알고있다.</p>\n<p>그래서 컴퓨터는 우리가 작성한 코드를 실행하기 위해서 이 코드를 자기가 해석하기 쉬운 형태로 <code>변환</code> 하는 과정을 거치는데, 이 과정을 우리는 <code>컴파일</code> 이라고 부른다.</p>\n<p>그렇게 코드를 <code>컴파일</code> 하는 역할을 하는 녀석을 <code>컴파일러</code> 라고 부르는데, 타입스크립트의 컴파일러는 다른 언어들과 동일하게 먼저 타입스크립트 코드를 AST(추상 문법 트리) 로 변환한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/2ff19487-49f0-4fa5-8003-5e0dbad95a32/image.png\" alt=\"\"></p>\n<p>그 다음 AST를 바이트코드로 변환하는 것이 아니라 AST를 보고 코드 상에 타입 오류가 없는지 검사하는 <code>타입 검사</code> 가 수행됩니다.</p>\n<p>만약 이때 코드에 타입 오류가 발견된다면, 타입 검사가 실패하고, 컴파일이 중단되는 것이다. 만약 타입 오류가 없는 <code>정상적인 코드</code> 라면 타입 검사를 성공적으로 통과하고 그 다음에는 AST를 바이트 코드가 아니라 <code>자바스크립트 코드</code> 로 변환하고, 컴파일이 종료된다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/bdfb8e45-f20e-44ea-a572-863873071cec/image.png\" alt=\"\"></p>\n<p>즉, 타입스크립트 코드는 </p>\n<blockquote>\n<p>타입 검사가 완료된 자바스크립트 코드</p>\n</blockquote>\n<p>라는 것이다. 그렇기에 타입 오류가 발생할 가능성이 낮은 <code>안전한 코드</code> 를 제공할 수 있는 것</p>\n<p><a href=\"https://ts.winterlood.com/d67c7b28-c191-46ee-9bdc-2ae8643c2028#438ae44d854f408bae659f045e04bc98\">출처 : 한 입 크기로 잘라먹는 타입스크립트</a></p>\n",
    "pubDate": "Wed, 30 Oct 2024 03:59:51 GMT",
    "thumbnail": null
  },
  {
    "title": "TypeScript 란?",
    "link": "https://velog.io/@gawgjiug/TypeScript-%EB%9E%80",
    "description": "<p>TypeScript 는 JS의 한게점을 극복하기 위해 개발된 언어이다.</p>\n<p>우선 JS 의 <code>한계점</code> 은 무엇일까? 자바스크립트가 사용하는 동적 타입 시스템은 기본적으로 변수의 타입들을 코드가 실행되는 도중 즉, <code>런타임</code> 에 결정하기 때문에 개발자가 미리 변수에 타입을 설정하지 않아도 된다는 점이다.</p>\n<p>이러한 점은 자바스크립트의 유연함과 장점으로도 평가되지만, 이러한 유동성이 단점으로도 작용한다는 것이다.</p>\n<pre><code class=\"language-javascript\">let a = &quot;heelo&quot; //문자열</code></pre>\n<p>이 JS 코드가 아마 Java에서는 이런식으로 작성 될 것이다.</p>\n<pre><code class=\"language-java\">String greeting = &quot;hello&quot;;</code></pre>\n<p>그리고 여기서 말하는 JS의 <code>단점</code> 은 이런 경우에서 발생한다. </p>\n<pre><code class=\"language-javascript\">let a = &quot;heelo&quot;;\na = 20000323\n\na.toUpperCase();</code></pre>\n<p>이러한 코드가 있다고 가정할 때, JS 에서는 이 코드를 <code>실행</code> 하고 오류가 발생한다. 그리고 프로그램이 비정상적으로 종료되게 되는데, 그 이유는 toUpperCase() 는 문자열에만 사용할 수 있는 메서드인데 a 에는 숫자가 들어있기 때문</p>\n<p>여기서 우리가 주목해야 할 부분은 이 코드가 <code>실행</code> 이 된다는 것이다. 애초에 이렇게 오류가 발생할 코드 였다면 실행 전에 검사를 거쳐서 실행하지 못하도록 막는 것이 더 좋은 방법인데,</p>\n<p>왜냐면 지금 보여준 예제코드는 매우 간단한 편이라 작성하면서도, 그리고 실행하자마자 오류를 확인할 수 있지만, 아주 복잡한 프로그램을 만들 때에는 저런 오류가 실행과 동시에 혹은 타이핑과 동시에 알 수 없다면 큰 문제가 될 수 있다.</p>\n<h3 id=\"정적-타입-시스템\">정적 타입 시스템</h3>\n<p>그러면 정적 타입 시스템을 사용하면 되는 것 아닌가? </p>\n<p>C와 Java 같은 정적 타입 시스템 언어들에서는 모든 변수에 일일히 타입을 다 정의해야 하기 때문에 작성해야 하는 코드의 양이 매우 늘어나고 DX에도 부정적인 영향을 줄 수 있다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/800c7a3c-748a-4596-817a-a55985dc66c5/image.png\" alt=\"\"></p>\n<h3 id=\"그래서-타입스크립트\">그래서 타입스크립트</h3>\n<p>그래서 타입스크립트는 동적과 정적 타입 시스템의 단점을 보완할 수 있는 방법을 사용하는데, 우선 타입스크립트에서는 마치 정적 타입 시스템 처럼 변수의 타입을 코드 실행 전에 결정하고 <code>type error</code> 가 없는지 프로그램 실행전에 코드를 검사한다. </p>\n<pre><code class=\"language-typescript\">\nlet a : number = 1;\n\na.toUpperCase();</code></pre>\n<p>이런식으로 변수 <code>a</code> 를 number 타입으로 정의했기 때문에 <code>a</code> 에 toUpperCase() 같은 문자열 메서드를 사용하려고 하면 TS에서는 미리 에러를 우리에게 보여주게 된다.</p>\n<p>그런데 타입스크립트는 앞서 말했듯이 JS의 유연함 또한 가지고 있다.</p>\n<pre><code class=\"language-typescript\">let a = 1;\na.toUpperCase();</code></pre>\n<p>다음 예제코드도 변수 a의 타입을 정의하지 않았음에도 변수 a를 숫자 타입으로 자동으로 인지해서 코드에 오류가 있음을 알려준다.</p>\n<p>즉, 타입스크립트는 변수의 타입을 우리가 직접 정의하지 않아도 변수에 담기는 초기값을 기준으로 자동으로 알아서 타입을 추론한다는 것이다.</p>\n<p>그리고 이런 타입시스템을 <code>점진적</code> 으로 타입을 결정한다 라고 해서 <code>점진적 타입 시스템</code> 이라고 부른다.</p>\n<p><a href=\"https://ts.winterlood.com/228976ad-1b7a-40c8-91a3-c0e0fbcb6701#47d45be94cf4421e88291446b998256c\">출처</a></p>\n",
    "pubDate": "Wed, 30 Oct 2024 02:02:13 GMT",
    "thumbnail": null
  },
  {
    "title": "패키지 Manager~",
    "link": "https://velog.io/@gawgjiug/%ED%8C%A8%ED%82%A4%EC%A7%80-Manager",
    "description": "<h3 id=\"패키지-매니저란\">패키지 매니저란?</h3>\n<ul>\n<li><p>패키지 매니저는 <code>패키지</code>를 다루는 작업을 편리하고 안전하게 수행하기 위해 사용되는 툴을 말한다.</p>\n</li>\n<li><p>더 간단히 얘기하면 <code>JavaScript</code> 나 <code>TypeScript</code> 를 사용하면서 발생하는 <code>require</code> 나 <code>import</code> 구문을 사용하는 외부 의존성 참조를 올바르게 참조할 수 있도록 보장해주는 프로그램이다</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">import React from &#39;/Users/raon0211/path/to/react/index.js&#39;;\nimport { sum } from &#39;/Users/raon0211/path/to/@toss/utils/index.js&#39;</code></pre>\n<p>JavaScript 표준에 따르면, 원래는 정확한 절대경로나 상대 경로를 통해서만 <code>import</code> 할 수 있었지만, 이렇게 쓰다보면 개발자 경험에 좋지 않은 영향을 준다.</p>\n<p>그래서 우리는 보통 이런식으로 import 문을 작성한다</p>\n<pre><code class=\"language-javascript\">import React from &#39;react&#39;;\nimport { sum } from &#39;@toss/utils&#39;;</code></pre>\n<p>하지만 이렇게 하면 문제가 발생할 수 있다. 예를 들어 <code>react</code> 가 정확히 어떤 버전인지, <code>@toss/utils</code> 이 어떤 버전인지 명확히 알 수 없다는 것이다. </p>\n<p>React 에는 여러가지 버전이 존재하기 때문에 정확한 정보의 제공이 필요한데, 그런 <code>정확한 버전 정보</code> 를 일반적으로 <code>pakage.json</code> 파일에 의존성을 명시하고, <code>npm</code> 또는 <code>yarn</code> 을 이용해서 의존성의 명시된 버전을 설치하는 것이다.</p>\n<p>즉 <strong>패키지 매니저가 앞서 이야기 한 모호한 버저닝 문제를 해결해주는 것</strong></p>\n<h3 id=\"패키지-매니저의-동작단계\">패키지 매니저의 동작단계</h3>\n<p>그렇다면 패키지 매니저는 어떤 방식으로 동작할까? </p>\n<p><code>Yarn</code> 을 포함한 패키지 매니저는 <code>Resolution</code> <code>Fetch</code> <code>Link</code> 세 단계로 동작한다. </p>\n<h4 id=\"resolution-단계\">Resolution 단계</h4>\n<ul>\n<li><p>라이브러리 버전 고정</p>\n</li>\n<li><p>라이브러리의 다른 의존성 확인</p>\n</li>\n<li><p>라이브러리의 다른 의존성 버전 고정</p>\n</li>\n</ul>\n<p>첫 번째 단계인 <strong>Resolution</strong> 단계는 <code>어떠한 문제를 해결하는 단계</code> 를 말합니다. 첫 번째 문제는 라이브러리를 정확한 버전으로 고정하는 문제입니다.</p>\n<p>패키지 매니저는 Resolution 단계에서 <code>pakage.json</code> 파일에 명시된 버전 범위에 따라 정확한 버전을 결정합니다.</p>\n<p>구체적으로 예를 들면, react 18.2.0 이라고 명시되어 있으면, 패키지 매니저의 규칙에 따라 ≥ 18.2.0, &lt;19 사이의 어떠한 버전이든 사용할 수 있는 것이다.</p>\n<p>패키지 매니저는 저 범위를 만족하는 선에서 가능한 최신 버전을 사용하려고 하는 것이다.</p>\n<p>그리고 그 다음은 설치한 라이브러리가 사용하는 <code>다른 라이브러리</code> 즉, 의존성의 의존성을 확인하는 작업을 가집니다.</p>\n<p>그리고 마지막으로는 <code>의존성의 의존성</code> 의 버전도 고정하는 것이 <code>Resolution</code> 단계라고 할 수 있다.</p>\n<p>그래서 다시 정리하자면, Resolution 단계는 모든 기기에서 고정된 버전을 사용할 수 있도록 하는 것이다. 의존성 버전을 모두 고정시키고, 그 <code>의존성의 의존성</code> 을 다 찾아내서 그 버전도 고정시키는 것.</p>\n<p>그리고 그 결과물이 <code>yarn.lock</code> 이나 <code>package-lock.json</code> 에 저장된다.</p>\n<h3 id=\"fetch-단계\">Fetch 단계</h3>\n<ul>\n<li>Fetch 단계는 한 줄로 요약하면 <code>결정된 버전의 파일을 다운로드 하는 과정</code> 을 말하는 것이다.</li>\n</ul>\n<p>방금 전 <code>yarn.lock</code> 에 명시된 패키지를 네트워크를 통해 필요한 파일들을 가져온다. </p>\n<h3 id=\"link-단계\">Link 단계</h3>\n<ul>\n<li>Link 단계는 Resolution/Fetch 된 라이브러리를 소스 코드에서 사용할 수 있는 환경을 제공하는 과정을 말한다.</li>\n</ul>\n<h4 id=\"npm-linker\">npm Linker</h4>\n<p>우리에게 가장 익숙한 <code>node_modules</code> 기반의 Linker는 <code>pakage.json</code> 에서 명시하는 모든 의존성을 그냥 <code>node_modules</code> 디렉토리 밑에다가 하나하나씩 써버리는 것이 npm Linker의 역할이다.</p>\n<p>예를 들어 소스 코드에서 특정한 라이브러리를 사용한다면, 루트 폴더 하위의 <code>node_modules</code> 에 해당 패키지를 추가하고, 추가 된 패키지에도 <code>node_modules</code> 가 있다면 다시 깔아주는 것이 npm Linker가 하는 일이다.</p>\n<p>이 방식에는 꽤나 많은 단점이 존재하는데, 일단 패키지를 찾는 것이 어려울 수 있다. 이 단점은 개발자 뿐만 아니라 npm Linker에게도 적용되기 때문에, 당연히 <code>import</code> 나 <code>require</code> 하는 속도가 느려지는 것이다.</p>\n<p>그리고 디렉토리의 크기가 너무 커지는 단점이 있다. 예를 들어 만약 100개의 프로젝트에서 혹은 폴더에서 React 18.2.0 버전을 사용한다고 하면, 정말로 100번씩 해당 버전이 추가되는 것이다.</p>\n<p>그래서 우리가 잘 알고 있는 <code>호이스팅</code> 이라는 방법을 사용하기도 하는데, 최적화가 완전히 되는것은 아니기 때문에 좋은 해결방법은 아닌 것이다.</p>\n<h4 id=\"yarn\">Yarn</h4>\n<p>반면에 yarn은 패키지 매니저의 각 구성요소가 모듈화되어 있고, 인터페이스가 잘 분리되어 있기 때문에, <code>Resolution</code> 단계의 코드와 <code>Fetch</code> 단계 , <code>Link</code> 단계의 코드가 섞여있지 않고 모듈화 되어있는 것은 yarn PnP 밖에 없다.</p>\n<p>더 자세하게 얘기하자면, npm은 모든 의존성을 <code>node_modules</code> 폴더 아래에 설치하고, 트리 형태로 하위 의존성도 폴더 내부에 중첩시킨다.</p>\n<p>반면에, Yarn PnP 방식은 <code>node_modules</code> 없이 직접 패키지들을 참조하고, <code>.pnp.js</code> 파일을 참조하여 의존성 위치를 추적할 수 있다.</p>\n<p>그리고 두 번째 장점은 <code>성능</code> 이다 PnP는 파일 I/O의 수가 적고, 설치 과정이 간단하기 때문에 속도가 매우 빠른편이다. </p>\n<p>그 설치과정을 살펴보면, npm 같은 경우 <code>pakage.json</code> 과 <code>pakage-lock.json</code> 에 따라 의존성 버전을 확인하고 <code>모든 의존성</code> 을 <code>node_modules</code> 폴더 하위에 설치하고, 각 하위 의존성도 중첩하여 <code>node_modules</code> 내에 폴더 구조를 생성한다.</p>\n<p>반면에 Yarn Pnp 방식은 <code>pakage.json</code> 과 <code>yarn.lock</code> 파일을 참고하여 의존성 버전을 고정하고, 모든 의존성 파일을 <code>로컬 캐시</code> 에 저장한다. 이 캐시 파일들은 Yarn 이 직접 관리 하므로, <code>node_modules</code> 폴더가 필요 없는 것이다.</p>\n<p>즉, 폴더 생성 및 중첩 없이 <code>.pnp.js</code> 파일 하나만으로 의존성을 관리하므로 <code>파일 I/O</code> 의 수가 적고 속도가 빠른것.</p>\n<p>그리고 마지막 장점은 <code>확장 가능성</code> 인데, Yarn은 코어 부분을 제외하면 전부 플러그인화가 되어 있어서, 다양한 기능을 쉽게 추가할 수 있다는 장점이 있다. 그래서 조직 내에서 자체적으로 여러 플러그인을 만들어서 사용하는 것이 가능하다.</p>\n",
    "pubDate": "Tue, 29 Oct 2024 16:06:13 GMT",
    "thumbnail": null
  }
]