[
  {
    "title": "TypeScript 란?",
    "link": "https://velog.io/@gawgjiug/TypeScript-%EB%9E%80",
    "description": "<p>TypeScript 는 JS의 한게점을 극복하기 위해 개발된 언어이다.</p>\n<p>우선 JS 의 <code>한계점</code> 은 무엇일까? 자바스크립트가 사용하는 동적 타입 시스템은 기본적으로 변수의 타입들을 코드가 실행되는 도중 즉, <code>런타임</code> 에 결정하기 때문에 개발자가 미리 변수에 타입을 설정하지 않아도 된다는 점이다.</p>\n<p>이러한 점은 자바스크립트의 유연함과 장점으로도 평가되지만, 이러한 유동성이 단점으로도 작용한다는 것이다.</p>\n<pre><code class=\"language-javascript\">let a = &quot;heelo&quot; //문자열</code></pre>\n<p>이 JS 코드가 아마 Java에서는 이런식으로 작성 될 것이다.</p>\n<pre><code class=\"language-java\">String greeting = &quot;hello&quot;;</code></pre>\n<p>그리고 여기서 말하는 JS의 <code>단점</code> 은 이런 경우에서 발생한다. </p>\n<pre><code class=\"language-javascript\">let a = &quot;heelo&quot;;\na = 20000323\n\na.toUpperCase();</code></pre>\n<p>이러한 코드가 있다고 가정할 때, JS 에서는 이 코드를 <code>실행</code> 하고 오류가 발생한다. 그리고 프로그램이 비정상적으로 종료되게 되는데, 그 이유는 toUpperCase() 는 문자열에만 사용할 수 있는 메서드인데 a 에는 숫자가 들어있기 때문</p>\n<p>여기서 우리가 주목해야 할 부분은 이 코드가 <code>실행</code> 이 된다는 것이다. 애초에 이렇게 오류가 발생할 코드 였다면 실행 전에 검사를 거쳐서 실행하지 못하도록 막는 것이 더 좋은 방법인데,</p>\n<p>왜냐면 지금 보여준 예제코드는 매우 간단한 편이라 작성하면서도, 그리고 실행하자마자 오류를 확인할 수 있지만, 아주 복잡한 프로그램을 만들 때에는 저런 오류가 실행과 동시에 혹은 타이핑과 동시에 알 수 없다면 큰 문제가 될 수 있다.</p>\n<h3 id=\"정적-타입-시스템\">정적 타입 시스템</h3>\n<p>그러면 정적 타입 시스템을 사용하면 되는 것 아닌가? </p>\n<p>C와 Java 같은 정적 타입 시스템 언어들에서는 모든 변수에 일일히 타입을 다 정의해야 하기 때문에 작성해야 하는 코드의 양이 매우 늘어나고 DX에도 부정적인 영향을 줄 수 있다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/800c7a3c-748a-4596-817a-a55985dc66c5/image.png\" alt=\"\"></p>\n<h3 id=\"그래서-타입스크립트\">그래서 타입스크립트</h3>\n<p>그래서 타입스크립트는 동적과 정적 타입 시스템의 단점을 보완할 수 있는 방법을 사용하는데, 우선 타입스크립트에서는 마치 정적 타입 시스템 처럼 변수의 타입을 코드 실행 전에 결정하고 <code>type error</code> 가 없는지 프로그램 실행전에 코드를 검사한다. </p>\n<pre><code class=\"language-typescript\">\nlet a : number = 1;\n\na.toUpperCase();</code></pre>\n<p>이런식으로 변수 <code>a</code> 를 number 타입으로 정의했기 때문에 <code>a</code> 에 toUpperCase() 같은 문자열 메서드를 사용하려고 하면 TS에서는 미리 에러를 우리에게 보여주게 된다.</p>\n<p>그런데 타입스크립트는 앞서 말했듯이 JS의 유연함 또한 가지고 있다.</p>\n<pre><code class=\"language-typescript\">let a = 1;\na.toUpperCase();</code></pre>\n<p>다음 예제코드도 변수 a의 타입을 정의하지 않았음에도 변수 a를 숫자 타입으로 자동으로 인지해서 코드에 오류가 있음을 알려준다.</p>\n<p>즉, 타입스크립트는 변수의 타입을 우리가 직접 정의하지 않아도 변수에 담기는 초기값을 기준으로 자동으로 알아서 타입을 추론한다는 것이다.</p>\n<p>그리고 이런 타입시스템을 <code>점진적</code> 으로 타입을 결정한다 라고 해서 <code>점진적 타입 시스템</code> 이라고 부른다.</p>\n<p><a href=\"https://ts.winterlood.com/228976ad-1b7a-40c8-91a3-c0e0fbcb6701#47d45be94cf4421e88291446b998256c\">출처</a></p>\n",
    "pubDate": "Wed, 30 Oct 2024 02:02:13 GMT",
    "thumbnail": null
  },
  {
    "title": "패키지 Manager~",
    "link": "https://velog.io/@gawgjiug/%ED%8C%A8%ED%82%A4%EC%A7%80-Manager",
    "description": "<h3 id=\"패키지-매니저란\">패키지 매니저란?</h3>\n<ul>\n<li><p>패키지 매니저는 <code>패키지</code>를 다루는 작업을 편리하고 안전하게 수행하기 위해 사용되는 툴을 말한다.</p>\n</li>\n<li><p>더 간단히 얘기하면 <code>JavaScript</code> 나 <code>TypeScript</code> 를 사용하면서 발생하는 <code>require</code> 나 <code>import</code> 구문을 사용하는 외부 의존성 참조를 올바르게 참조할 수 있도록 보장해주는 프로그램이다</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">import React from &#39;/Users/raon0211/path/to/react/index.js&#39;;\nimport { sum } from &#39;/Users/raon0211/path/to/@toss/utils/index.js&#39;</code></pre>\n<p>JavaScript 표준에 따르면, 원래는 정확한 절대경로나 상대 경로를 통해서만 <code>import</code> 할 수 있었지만, 이렇게 쓰다보면 개발자 경험에 좋지 않은 영향을 준다.</p>\n<p>그래서 우리는 보통 이런식으로 import 문을 작성한다</p>\n<pre><code class=\"language-javascript\">import React from &#39;react&#39;;\nimport { sum } from &#39;@toss/utils&#39;;</code></pre>\n<p>하지만 이렇게 하면 문제가 발생할 수 있다. 예를 들어 <code>react</code> 가 정확히 어떤 버전인지, <code>@toss/utils</code> 이 어떤 버전인지 명확히 알 수 없다는 것이다. </p>\n<p>React 에는 여러가지 버전이 존재하기 때문에 정확한 정보의 제공이 필요한데, 그런 <code>정확한 버전 정보</code> 를 일반적으로 <code>pakage.json</code> 파일에 의존성을 명시하고, <code>npm</code> 또는 <code>yarn</code> 을 이용해서 의존성의 명시된 버전을 설치하는 것이다.</p>\n<p>즉 <strong>패키지 매니저가 앞서 이야기 한 모호한 버저닝 문제를 해결해주는 것</strong></p>\n<h3 id=\"패키지-매니저의-동작단계\">패키지 매니저의 동작단계</h3>\n<p>그렇다면 패키지 매니저는 어떤 방식으로 동작할까? </p>\n<p><code>Yarn</code> 을 포함한 패키지 매니저는 <code>Resolution</code> <code>Fetch</code> <code>Link</code> 세 단계로 동작한다. </p>\n<h4 id=\"resolution-단계\">Resolution 단계</h4>\n<ul>\n<li><p>라이브러리 버전 고정</p>\n</li>\n<li><p>라이브러리의 다른 의존성 확인</p>\n</li>\n<li><p>라이브러리의 다른 의존성 버전 고정</p>\n</li>\n</ul>\n<p>첫 번째 단계인 <strong>Resolution</strong> 단계는 <code>어떠한 문제를 해결하는 단계</code> 를 말합니다. 첫 번째 문제는 라이브러리를 정확한 버전으로 고정하는 문제입니다.</p>\n<p>패키지 매니저는 Resolution 단계에서 <code>pakage.json</code> 파일에 명시된 버전 범위에 따라 정확한 버전을 결정합니다.</p>\n<p>구체적으로 예를 들면, react 18.2.0 이라고 명시되어 있으면, 패키지 매니저의 규칙에 따라 ≥ 18.2.0, &lt;19 사이의 어떠한 버전이든 사용할 수 있는 것이다.</p>\n<p>패키지 매니저는 저 범위를 만족하는 선에서 가능한 최신 버전을 사용하려고 하는 것이다.</p>\n<p>그리고 그 다음은 설치한 라이브러리가 사용하는 <code>다른 라이브러리</code> 즉, 의존성의 의존성을 확인하는 작업을 가집니다.</p>\n<p>그리고 마지막으로는 <code>의존성의 의존성</code> 의 버전도 고정하는 것이 <code>Resolution</code> 단계라고 할 수 있다.</p>\n<p>그래서 다시 정리하자면, Resolution 단계는 모든 기기에서 고정된 버전을 사용할 수 있도록 하는 것이다. 의존성 버전을 모두 고정시키고, 그 <code>의존성의 의존성</code> 을 다 찾아내서 그 버전도 고정시키는 것.</p>\n<p>그리고 그 결과물이 <code>yarn.lock</code> 이나 <code>package-lock.json</code> 에 저장된다.</p>\n<h3 id=\"fetch-단계\">Fetch 단계</h3>\n<ul>\n<li>Fetch 단계는 한 줄로 요약하면 <code>결정된 버전의 파일을 다운로드 하는 과정</code> 을 말하는 것이다.</li>\n</ul>\n<p>방금 전 <code>yarn.lock</code> 에 명시된 패키지를 네트워크를 통해 필요한 파일들을 가져온다. </p>\n<h3 id=\"link-단계\">Link 단계</h3>\n<ul>\n<li>Link 단계는 Resolution/Fetch 된 라이브러리를 소스 코드에서 사용할 수 있는 환경을 제공하는 과정을 말한다.</li>\n</ul>\n<h4 id=\"npm-linker\">npm Linker</h4>\n<p>우리에게 가장 익숙한 <code>node_modules</code> 기반의 Linker는 <code>pakage.json</code> 에서 명시하는 모든 의존성을 그냥 <code>node_modules</code> 디렉토리 밑에다가 하나하나씩 써버리는 것이 npm Linker의 역할이다.</p>\n<p>예를 들어 소스 코드에서 특정한 라이브러리를 사용한다면, 루트 폴더 하위의 <code>node_modules</code> 에 해당 패키지를 추가하고, 추가 된 패키지에도 <code>node_modules</code> 가 있다면 다시 깔아주는 것이 npm Linker가 하는 일이다.</p>\n<p>이 방식에는 꽤나 많은 단점이 존재하는데, 일단 패키지를 찾는 것이 어려울 수 있다. 이 단점은 개발자 뿐만 아니라 npm Linker에게도 적용되기 때문에, 당연히 <code>import</code> 나 <code>require</code> 하는 속도가 느려지는 것이다.</p>\n<p>그리고 디렉토리의 크기가 너무 커지는 단점이 있다. 예를 들어 만약 100개의 프로젝트에서 혹은 폴더에서 React 18.2.0 버전을 사용한다고 하면, 정말로 100번씩 해당 버전이 추가되는 것이다.</p>\n<p>그래서 우리가 잘 알고 있는 <code>호이스팅</code> 이라는 방법을 사용하기도 하는데, 최적화가 완전히 되는것은 아니기 때문에 좋은 해결방법은 아닌 것이다.</p>\n<h4 id=\"yarn\">Yarn</h4>\n<p>반면에 yarn은 패키지 매니저의 각 구성요소가 모듈화되어 있고, 인터페이스가 잘 분리되어 있기 때문에, <code>Resolution</code> 단계의 코드와 <code>Fetch</code> 단계 , <code>Link</code> 단계의 코드가 섞여있지 않고 모듈화 되어있는 것은 yarn PnP 밖에 없다.</p>\n<p>더 자세하게 얘기하자면, npm은 모든 의존성을 <code>node_modules</code> 폴더 아래에 설치하고, 트리 형태로 하위 의존성도 폴더 내부에 중첩시킨다.</p>\n<p>반면에, Yarn PnP 방식은 <code>node_modules</code> 없이 직접 패키지들을 참조하고, <code>.pnp.js</code> 파일을 참조하여 의존성 위치를 추적할 수 있다.</p>\n<p>그리고 두 번째 장점은 <code>성능</code> 이다 PnP는 파일 I/O의 수가 적고, 설치 과정이 간단하기 때문에 속도가 매우 빠른편이다. </p>\n<p>그 설치과정을 살펴보면, npm 같은 경우 <code>pakage.json</code> 과 <code>pakage-lock.json</code> 에 따라 의존성 버전을 확인하고 <code>모든 의존성</code> 을 <code>node_modules</code> 폴더 하위에 설치하고, 각 하위 의존성도 중첩하여 <code>node_modules</code> 내에 폴더 구조를 생성한다.</p>\n<p>반면에 Yarn Pnp 방식은 <code>pakage.json</code> 과 <code>yarn.lock</code> 파일을 참고하여 의존성 버전을 고정하고, 모든 의존성 파일을 <code>로컬 캐시</code> 에 저장한다. 이 캐시 파일들은 Yarn 이 직접 관리 하므로, <code>node_modules</code> 폴더가 필요 없는 것이다.</p>\n<p>즉, 폴더 생성 및 중첩 없이 <code>.pnp.js</code> 파일 하나만으로 의존성을 관리하므로 <code>파일 I/O</code> 의 수가 적고 속도가 빠른것.</p>\n<p>그리고 마지막 장점은 <code>확장 가능성</code> 인데, Yarn은 코어 부분을 제외하면 전부 플러그인화가 되어 있어서, 다양한 기능을 쉽게 추가할 수 있다는 장점이 있다. 그래서 조직 내에서 자체적으로 여러 플러그인을 만들어서 사용하는 것이 가능하다.</p>\n",
    "pubDate": "Tue, 29 Oct 2024 16:06:13 GMT",
    "thumbnail": null
  },
  {
    "title": "일급 객체와 JS 함수 뜯어보기",
    "link": "https://velog.io/@gawgjiug/%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4%EC%99%80-JS-%ED%95%A8%EC%88%98-%EB%9C%AF%EC%96%B4%EB%B3%B4%EA%B8%B0",
    "description": "<h3 id=\"일급-객체\">일급 객체</h3>\n<blockquote>\n<p>일급객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다.</p>\n</blockquote>\n<p><strong>일급객체</strong>란 구체적으론 다음과 같은 조건을 만족하는 객체를 <code>일급 객체</code> 라 한다.</p>\n<ol>\n<li><p>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</p>\n</li>\n<li><p>변수나 자료구조(객체,배열 등)에 저장할 수 있다.</p>\n</li>\n<li><p>함수의 매개변수에 전달할 수 있다.</p>\n</li>\n<li><p>함수의 반환 값으로 사용할 수 있다.</p>\n</li>\n</ol>\n<p>자바스크립트의 함수는 위의 조건을 모두 만족하는 일급 객체이다.</p>\n<p>다른 건 다 직관적으로 이해할 수 있겠지만, 헷갈릴 수 있는 1번 조건에 대해 알아보자</p>\n<pre><code class=\"language-javascript\">// 1. 무명의 리터럴로 생성 후 즉시 실행 (IIFE - 즉시 실행 함수 표현)\n(function() {\n  console.log(&#39;이 함수는 무명 리터럴로 런타임에 생성되고 바로 실행됩니다!&#39;);\n})();</code></pre>\n<ul>\n<li><p>위 코드는 함수를 <code>function</code> 키워드로 정의했지만 이름을 붙이지 않은 <strong>익명 함수</strong> 이다</p>\n</li>\n<li><p>이 익명 함수는 정의와 동시에 <strong>즉시 실행(IIFE) 된다</strong> 이런 방식은 함수를 특정 시점에 런타임에서 직접 생성하고 바로 사용하고자 할 때 많이 활용된다.</p>\n</li>\n<li><p>이런 방식은 함수를 특정 시점에 <code>런타임</code> 에서 직접 생성하고 바로 사용하고자 할 때 많이 활용된다. </p>\n</li>\n<li><p>여기서 <code>런타임</code>에 생성 가능하다는 의미가 무엇이냐??</p>\n</li>\n</ul>\n<blockquote>\n<p>런타임은 프로그램이 실행 중일 때를 의미한다. 즉, 런타임에 생성 가능하다는 것은 프로그램이 실행되는 도중에 필요한 시점에 함수를 새로 생성하고 사용할 수 있는 뜻을 말한다.</p>\n</blockquote>\n<h4 id=\"런타임-생성의-차이\">런타임 생성의 차이</h4>\n<pre><code class=\"language-javascript\">function sayHello() {\n  console.log(&quot;Hello!&quot;);\n}\nsayHello();  // &quot;Hello!&quot; 출력</code></pre>\n<ul>\n<li><p>이렇게 정적으로 함수를 선언한 경우, 프로그램이 시작되기 전에 미리 정의되는 것이다.</p>\n</li>\n<li><p>다시 말하면 이 함수는 코드가 실행되기 전에 메모리에 올라가 공간을 차지하는 것 </p>\n</li>\n</ul>\n<hr>\n<h4 id=\"변수에-무명-함수-저장\">변수에 무명 함수 저장</h4>\n<pre><code class=\"language-javascript\">const greet = function() {\n  console.log(&quot;Hello, World!&quot;);\n};\ngreet();  // &quot;Hello, World!&quot; 출력</code></pre>\n<ul>\n<li><p>이 경우 익명함수를 프로그램이 실행되는 도중 즉, 런타임에 생성한다.</p>\n</li>\n<li><p>함수를 정의한 코드가 실행될 때 비로소 메모리에 함수가 생성되고, 변수 <code>greet</code> 에 저장된다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"그래서-리터럴이란\">그래서 리터럴이란?</h4>\n<ul>\n<li><p>리터럴이란 코드를 작성할 때 고정된 값 자체를 표현하는 방식을 말한다.</p>\n</li>\n<li><p>프로그래밍 언어에서, 리터럴은 값을 직접 코드에 명시하는 것을 말한다.</p>\n</li>\n</ul>\n<p>즉, 함수 리터럴은 함수에 이름을 붙이지 않고, 곧 바로 코드에서 익명함수로 사용할 수 있는 것을 의미한다.</p>\n<hr>\n<h4 id=\"그래서-런타임-생성과-사용이-왜-유용한데\">그래서 런타임 생성과 사용이 왜 유용한데?</h4>\n<ul>\n<li><p>런타임에 함수를 생성한다는 것은 <strong>유연하게 함수</strong> 필요할 때 만들어 사용할 수 있다는 뜻을 말한다.</p>\n</li>\n<li><p>이를 통해 코드가 동적으로 변경되는 상황에 대응할 수 있다, 예를 들어 클릭 이벤트가 발생할 때 마다 새로운 함수를 만들고 호출할 수 있는 것</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">document.getElementById(&#39;myButton&#39;).addEventListener(&#39;click&#39;, function() {\n  console.log(&#39;버튼이 클릭되었습니다!&#39;);\n});</code></pre>\n<ul>\n<li><p>우리가 자주보는 이 문법은 사실 버튼 클릭 시 익명 함수를 즉석에서(런타임에) 생성하고 실행하는 것이다. </p>\n</li>\n<li><p>미리 정의된 함수 없이 이벤트가 발생할 때 마다 필요한 함수를 동적으로 생성하기 때문에 메모리 관리의 효율성 또한 상승할 수 있는 것</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"함수의-전달\">함수의 전달</h3>\n<p>일급 객체로서 함수가 가지는 가장 큰 특징은 함수의 매개변수에 전달할 수 있으며, 함수의 반환 값으로 사용할 수 있다는 것이다.</p>\n<blockquote>\n<p>이는 함수형 프로그래밍을 가능케 하는 자바스크립트의 장점 중 하나다</p>\n</blockquote>\n<pre><code class=\"language-javascript\">function repeatAction(n, action) {\n  for (let i = 0; i &lt; n; i++) {\n    action();  // 전달된 함수 실행\n  }\n}\n\n// &#39;Hello&#39;를 3번 출력하는 익명 함수 전달\nrepeatAction(3, function() {\n  console.log(&quot;Hello!&quot;);\n});</code></pre>\n<ul>\n<li>이처럼 함수를 매개변수로 전달해 특정 로직을 유연하게 적용하는 것이 가능 한 것.</li>\n</ul>\n<hr>\n<h3 id=\"함수-객체의-프로퍼티\">함수 객체의 프로퍼티</h3>\n<p>브라우저 콘솔에서 <code>console.dir</code> 를 입력해서 함수 객체의 내부를 쉽게 들여다 볼 수 있다.</p>\n<blockquote>\n<p>왜 함수 객체의 프로퍼티를 이해해야 할까?</p>\n</blockquote>\n<ol>\n<li>함수도 객체이기 때문</li>\n</ol>\n<ul>\n<li><p>자바스크립트에서는 함수도 일급 객체로 취급 되기 때문이다. 이는 함수가 변수에 할당되거나, 다른 함수의 인자로 전달, 함수에서 반환될 수 있다는 의미이다.</p>\n</li>\n<li><p>함수를 객체처럼 다룰 수 있기 때문에 프로퍼티와 메서드를 추가하거나 내장된 프로퍼티에 접근하는 것 또한 가능하기 때문.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">function exampleFunction(a, b) {\n  return a + b;\n}\n\n// 브라우저 콘솔에서 함수 객체의 내부를 확인\nconsole.dir(exampleFunction);\n</code></pre>\n<pre><code class=\"language-lua\">ƒ exampleFunction(a, b)\n  arguments: null\n  caller: null\n  length: 2\n  name: &quot;exampleFunction&quot;\n  prototype: {constructor: ƒ}\n  [[FunctionLocation]]: script.js:1\n  [[Scopes]]: Scopes[2]</code></pre>\n<p><code>console.dir</code> 은 객체의 내부 구조를 트리 형태로 펼쳐 보여주는 것이다. 이를 통해 함수 객체의 여러 프로퍼티들을 확인할 수 있는 것!</p>\n<h4 id=\"argument-프로퍼티\">argument 프로퍼티</h4>\n<p>함수 객체의 <code>argument</code> 프로퍼티 값은 함수 호출 시 전달 된 인수들의 정보를 담고 있는 argument 객체이다.</p>\n<p>마치 배열 객체처럼 순회 가능하다는 특징을 가지고 있다. 하지만 진짜 배열은 아니기 대문에 <code>map</code> 이나 <code>forEach</code> 와 같은 배열 메서드를 직접 사용할 수는 없고 Array 로 변환해야 한다.</p>\n<p>선언된 매개변수의 개수보다 인수를 적게 전달했을 경우 인수가 전달되지 않은 매개변수는 <code>undefined</code> 로 초기화된 상태이다</p>\n<pre><code class=\"language-javascript\">function example(a, b) {\n  console.log(&quot;a:&quot;, a);  // 첫 번째 인수\n  console.log(&quot;b:&quot;, b);  // 두 번째 인수\n  console.log(&quot;arguments:&quot;, arguments);  // 모든 인수 출력\n\n  // arguments 객체 순회\n  for (let i = 0; i &lt; arguments.length; i++) {\n    console.log(`arguments[${i}]:`, arguments[i]);\n  }\n}\n\n// 3개의 인수를 전달했지만 매개변수는 2개만 선언됨\nexample(1, 2, 3);</code></pre>\n<pre><code class=\"language-makefile\">a: 1\nb: 2\narguments: [1, 2, 3]\narguments[0]: 1\narguments[1]: 2\narguments[2]: 3</code></pre>\n<ol>\n<li><p>매개변수 a, b에는 전달된 첫 번째, 두 번째 인수가 각각 할당됩니다.</p>\n</li>\n<li><p>초과된 인수(여기서는 3)는 무시되지 않고 arguments 객체에 모두 담깁니다.</p>\n</li>\n<li><p><code>arguments</code> 객체를 순회하여 모든 전달된 인수를 확인할 수 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"사용자-정의-프로퍼티-추가-가능\">사용자 정의 프로퍼티 추가 가능</h3>\n<ul>\n<li>말했듯이 함수는 <code>객체</code> 이므로 사용자 정의 프로퍼티를 추가할 수 있다.</li>\n</ul>\n<pre><code class=\"language-javascript\">function greet() {\n  console.log(&quot;Hello!&quot;);\n}\ngreet.language = &quot;Korean&quot;;\n\nconsole.dir(greet);\nconsole.log(greet.language); // 출력: Korean\n</code></pre>\n<ul>\n<li>뿐만 아니라 [[Scope]] 같은 내부 정보도 확인할 수 있기 때문에 클로저를 이해하거나 디버깅할 때 유용하다</li>\n</ul>\n<hr>\n<h3 id=\"나머지-주요-프로퍼티\">나머지 주요 프로퍼티</h3>\n<h4 id=\"caller\">caller</h4>\n<ul>\n<li>이 함수가 어디서 호출되었는지 참조한다. 현재 호출한 함수가 없을 경우 <code>null</code></li>\n</ul>\n<h4 id=\"length\">length</h4>\n<ul>\n<li>함수가 기대하는 매개변수의 개수를 말한다. 위 예제에서는 두 개의 인수를 받기 때문에 <code>2</code> 이다.</li>\n</ul>\n<h4 id=\"name\">name</h4>\n<ul>\n<li>함수의 이름을 말한다. 익명 함수일 경우 <code>anoymous</code> 가 된다.</li>\n</ul>\n<h4 id=\"prototype\">prototype</h4>\n<ul>\n<li>함수가 생성자 함수로 사용될 때 새로 생성된 객체에 연결되는 프로토타입 객체를 말한다.</li>\n</ul>\n<h4 id=\"scopes\">[Scopes]</h4>\n<ul>\n<li>함수가 선언된 스코프 체인을 보여준다, 클로저를 사용한 경우 이 프로퍼티에서 클로저의 내부 상태를 확인할 수 있다.</li>\n</ul>\n",
    "pubDate": "Tue, 15 Oct 2024 14:16:57 GMT",
    "thumbnail": null
  },
  {
    "title": "숨바꼭질",
    "link": "https://velog.io/@gawgjiug/%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88",
    "description": "<p><a href=\"https://www.acmicpc.net/problem/13549\">13549번 : 숨바꼭질3</a></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/ca7a7d06-8a8d-4bb7-90d8-b4c17dc11c10/image.png\" alt=\"\"></p>\n<pre><code class=\"language-java\">package Gold_5;\n\nimport javax.xml.soap.Node;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class HideAndSeek {\n    //진행되는 연산은 3종류 +1,-1,*2 이다 이때 연산 순서도 중요함\n    static int min = Integer.MAX_VALUE;\n    static int n,k;\n    static boolean[] visited;\n    static int max = 100000; //수빈이가 이동할 수 있는 최대위치\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        k = sc.nextInt();\n\n        visited = new boolean[max+1]; //위치 범위는 0~10000\n        bfs();\n        System.out.println(min);\n\n\n    }\n\n    private static void bfs() {\n        Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();\n        q.offer(new Node(n,0)); //수빈이의 초기 위치와 시간(0)을 큐에 넣음\n        while(!q.isEmpty()) {\n            Node node = q.poll(); //현재위치를 node로 꺼내고 그 위치를 방문한 것으로 처리\n            visited[node.x] = true;\n            if(node.x == k) min = Math.min(min, node.time); //현재 위치가 동생의 위치 k와 같으면 최소시간 갱신\n\n            if(node.x * 2 &lt;= max &amp;&amp; visited[node.x * 2] == false) q.offer(new Node(node.x * 2, node.time));\n            if(node.x + 1 &lt;= max &amp;&amp; visited[node.x + 1] == false) q.offer(new Node(node.x + 1, node.time + 1));\n            if(node.x - 1 &gt;= 0 &amp;&amp; visited[node.x - 1] == false) q.offer(new Node(node.x - 1, node.time + 1));\n        }\n    }\n    public static class Node{\n        int x;\n        int time;\n        public Node(int x, int time){\n            this.x  = x;\n            this.time  = time;\n        }\n    }\n}</code></pre>\n<p>문제는 주어진 시작 위치 <code>n</code> 에서 동생의 위치 <code>k</code> 까지 이동하는 데 필요한 최소 시간을 계산하는 것이다.</p>\n<p>수빈이는 최대 100,000 까지의 위치로 이동할 수 있다. </p>\n<h3 id=\"접근-방식\">접근 방식</h3>\n<p>이 문제를 해결하기 위해 BFS(너비 우선 탐색) 알고리즘을 사용했다. BFS는 최단 경로 문제에 적합한 알고리즘으로 모든 가능한 위치를 탐색하며 최단 경로를 찾아내기 때문임.</p>\n<h3 id=\"코드-작동-방식\">코드 작동 방식</h3>\n<ol>\n<li><p>초기화 : 사용자의 입력을 받아 수빈이의 초기 위치 n과 동생의 위치를 설정 방문한 위치를 기록하기 위한 배열 <code>visited</code> 를 초기화함</p>\n</li>\n<li><p>BFS 실행: bfs 메서드에서 큐를 사용하여 수빈이의 위치와 경과 시간을 저장합니다. 큐에서 현재 위치를 꺼내고, 동생의 위치와 비교하여 최소 시간을 업데이트합니다.</p>\n</li>\n<li><p>이동 처리: 현재 위치에서 세 가지 이동 방법(두 배로 이동, +1 이동, -1 이동)을 모두 검사하고, 유효한 이동일 경우 큐에 추가합니다.</p>\n</li>\n<li><p>최종 결과 출력: 동생의 위치에 도달하는 최소 시간을 출력합니다.</p>\n</li>\n</ol>\n",
    "pubDate": "Fri, 11 Oct 2024 08:55:06 GMT",
    "thumbnail": null
  },
  {
    "title": "쿠키와 세션 개념",
    "link": "https://velog.io/@gawgjiug/%EC%BF%A0%ED%82%A4%EC%99%80-%EC%84%B8%EC%85%98-%EA%B0%9C%EB%85%90",
    "description": "<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/4116e816-5638-4019-88db-0c6875a70883/image.png\" alt=\"\"></p>\n<h4 id=\"http의-특징과-쿠키와-세션을-사용하는-이유\">HTTP의 특징과 쿠키와 세션을 사용하는 이유</h4>\n<ul>\n<li><p>쿠키와 세션을 사용하는 이유는 바로 HTTP 프로토콜의 특성이자 약점을 보완하기 위함이다</p>\n</li>\n<li><p>기본적으로 HTTP 프로토콜 환경은 <code>connectionless</code> <code>stateless</code> 한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 한다. </p>\n</li>\n<li><p>이러한 특성을 보완하기 위해서 쿠키와 세션을 사용하게 되는 것</p>\n</li>\n</ul>\n<blockquote>\n<p>connectionless 란?\n클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징을 말한다.\nHTTP 는 먼저 클라이언트가 request 를 서버에 보내면 , 서버는 클라이언트 요청에 맞는 response 를 보내고 접속을 끊는 특성이 있다.</p>\n</blockquote>\n<blockquote>\n<p>stateless 란?\n통신이 끝나면 상태를 유지하지 않는 특징을 말한다.\n연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있다.\n쿠키와 세션은 위의 두 가지 특징을 해결하기 위해 사용한다.</p>\n</blockquote>\n<blockquote>\n<p>HTTP? 란?\nHTTP(HyperText Transfer Protocol)는 월드 와이드 웹(WWW)에서 정보를 주고받기 위한 프로토콜이다. 쉽게 말해, 웹 브라우저와 서버가 인터넷을 통해 데이터를 주고받을 때 사용하는 규칙을 말하는데, 주로 웹 페이지(HTML), 이미지, 동영상, 파일 등의 데이터를 주고받는 데 사용된다.</p>\n</blockquote>\n<p>즉, 요청이 끝나면 서버는 유저가 누군지 잊어버리기 때문에, 요청 할 때마다. 우리가 누군지 <code>알려줘야</code> 한다는 것</p>\n<p>이를 하는 방법 중 하나가 <code>세션</code> 임 </p>\n<p>예를들어 <code>곽지욱</code> 이라는 유저가 있고 로그인 하고 싶다면 <code>유저명</code> 그리고 <code>비밀번호</code> 를 서버에 보내게 된다. </p>\n<p>비밀번호가 확인된다면 서버는 세션 DB에 <code>곽지욱</code> 이라는 유저를 생성한다 해당 세션에는 별도의 ID가 있고,</p>\n<p>해당 세션 ID는 쿠키를 통해 브라우저로 돌아오고 저장된다. 따라서 같은 웹 사이트의 다른 페이지로 이동하면 브라우저는 세션 ID를 갖고 있는 쿠키를 서버에게 보내게 된다.</p>\n<p>왜냐면 쿠키는 자동으로 보내지기 때문이다 </p>\n<p>서버는 들어오는 쿠키를 보고, 해당 세션 ID를 가지고 세션 DB를 확인할 것이고 거기서 해당 ID는 유저명 <code>곽지욱</code> 의 것이라는 것 알게되고. 그때 서버는 사용자를 구분할 수 있게 된다. </p>\n<p>이 작업이 끝나고 다른 페이지로 이동하게 되면 이 모든 프로세스가 반복되는 것</p>\n<p>여기서 중요한 건 모든 중요한 유저 데이터는 모두 서버에 있고 유저가 브라우저 상에서 갖고잇는 것은 세션 ID 뿐이라는 것이다.</p>\n<hr>\n<h4 id=\"쿠키cookie\">쿠키(Cookie)</h4>\n<ul>\n<li><p>쿠키란? 위에서 말했듯이 그저 세션 ID를 전달하기 위한 매개체일 뿐이다.</p>\n</li>\n<li><p>쿠키를 이용해서 서번는 나의 브라우저에 데이터를 넣을 수 있다.</p>\n</li>\n<li><p>사이트에 방문하면 브라우저는 서버에 <code>요청</code> 을 보내게 되는데, 서버는 이에 <code>response</code> (응답)을 할 것이고 , 그 <code>응답</code> 에는 모든 데이터와 내가 찾던 페이지 정보가 들어있다. </p>\n</li>\n<li><p>또한 그곳에는 브라우저에 저장하고자 하는 쿠키가 있을 수 있는 것이다.</p>\n</li>\n<li><p>이 쿠키는 내가 브라우저에 저장해두고 해당 웹 사이트에 방문할 때 마다 브라우저는 해당 쿠키도 요청과 함께 보내게 된다.</p>\n</li>\n<li><p>참고로 쿠키는 도메인에 따라 제한이 되는데, 이 말은 즉슨 유튜브가 준 쿠키는 유튜브 서버에만 보내지게 된다는 것이다.</p>\n</li>\n<li><p>그리고 쿠키는 유효기간을 가지고 있다. 유효기간에 따라 어떤 쿠키는 하루 혹은 한달 등.. 서버가 정한 기간에 따라 유효한 특징을 가지고 있다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"쿠키의-동작-방식-예시\">쿠키의 동작 방식 예시</h4>\n<p>그리고 쿠키는 인증 뿐만 아니라 여러가지 정보를 저장할 수 있는데, </p>\n<p>예를 들면 사용자가 웹 사이트 언어 설정을 바꾸면 서버는 쿠키를 브라우저에게 주고 사용자가 선택한 언어를 저장하게 된다.</p>\n<p>따라서 다음에 내가 해당 웹 사이트에 방문할 때 쿠키는 요청과 함께 서버로 보내지고 덕분에 서버는 쿠키가 기억해둔 언어설정의 페이지를 제공할 수 있는 것이다.</p>\n<hr>\n<h4 id=\"세션이란\">세션이란?</h4>\n<p>세션이란 이미 말했지만, 서버 측에서 사용자의 상태 정보를 관리하는 방식으로, 클라이언트와 서버 간의 지속적인 통신 상태를 유지하기 위해 사용된다. </p>\n<p>앞서 설명한 HTTP의 두 가지 특성으로 인해 서버는 클라이언트의 정보를 매번 새롭게 받아야 하는데,</p>\n<p>이를 해결하기 위해 서버가 클라이언트의 정보를 일정 시간 동안 저장하여, 각 요청에서 사용자를 식벽할 수 있도록 돕는 역할을 한다고 생각하면 된다.</p>\n<hr>\n<h4 id=\"세션의-동작-방식\">세션의 동작 방식</h4>\n<ol>\n<li><p>세션 생성 : 사용자가 웹에 로그인 하거나 중요한 작업을 수행할 때, 서버는 클라이언트의 정보를 서버 내부의 세션 저장소에 기록한다. </p>\n</li>\n<li><p>세션 ID 발급 : 서버는 클라이언트가 고유한 세션을 가질 수 있도록 세션 ID를 발급하고, 이 세션 ID는  클라이언트가 해당 서버에서 진행하는 활동을 식별하기 위한 고유 값이다. </p>\n</li>\n</ol>\n<p>세션 ID는 주로 쿠키에 담겨 클라이언트 측 브라우저에 저장된다.</p>\n<ol start=\"3\">\n<li><p>세션 유지: 클라이언트가 웹 사이트의 다른 페이지로 이동하거나 추가적인 요청을 보낼 때, 브라우저는 자동으로 쿠키게 저장된 세션 ID를 서버로 전달한다.</p>\n</li>\n<li><p>세션 종료 : 세션은 일정 시간이 지나면 만료되거나, 사용자가 로그아웃 하는 경우 명시적으로 삭제된다. </p>\n</li>\n</ol>\n",
    "pubDate": "Wed, 02 Oct 2024 07:45:20 GMT",
    "thumbnail": null
  },
  {
    "title": "SEO 와 시맨틱 마크업",
    "link": "https://velog.io/@gawgjiug/SEO-%EC%99%80-%EC%8B%9C%EB%A7%A8%ED%8B%B1-%EB%A7%88%ED%81%AC%EC%97%85",
    "description": "<p>최근에 <code>SEO</code> 그리고 <code>시맨틱 마크업</code> 에 대해 자주 이야기를 듣게되었다.</p>\n<p>우선 <code>SEO</code>가 무엇일까?</p>\n<h2 id=\"seo란\">SEO란?</h2>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/6bd09dc4-dedd-4f88-861d-a3b8bf5b58da/image.png\" alt=\"\"></p>\n<p>한국어로는 검색엔진 최적화, 영어로는 Search Engine Oprimization 을 줄여서 <code>SEO</code> 라고한다.</p>\n<p>한 마디로 <code>SEO</code> 는 웹사이트가 검색 엔진에서 더 잘 인식되고 순위가 높게 표시되도록 최적화 하는 과정을 말한다. 구글을 예로 들자면 검색 엔진은 웹 페이지의 콘텐츠를 <code>크롤링</code> 하고 이 정보를 기반으로 검색 결과를 노출시킨다.</p>\n<blockquote>\n<p>여기서 크롤링은 &#39;웹 상을 돌아다니면서 정보를 수집하는 행위&#39; 를 말한다.</p>\n</blockquote>\n<p>이때 <code>SEO</code>가 잘된 페이지는 검색 결과에서 상위에 노출되기 때문에 더 많은 사용자가 웹사이트를 방문하게 된다. 이로 인해 자연 검색(Natural Search) 트래픽이 증가하게 되는 것.</p>\n<h2 id=\"시맨틱-마크업이란\">시맨틱 마크업이란?</h2>\n<p>시맨틱 마크업은 Semantic(의미론적인) + Markup(HTML 태그로 문서를 작성하는 것) 의 합성어이다.</p>\n<p>즉,<code>시멘틱 마크업</code> 이란 의미론적인 HTML 태그를 작성하는 것이라고 할 수 있다. HTML 태그에는 각각의 의미가 존재한다. </p>\n<blockquote>\n<p>헤더/푸터에 header와 footer 사용\n메인 컨텐츠에 main과 section 사용\n내비게이션에 nav 사용</p>\n</blockquote>\n<p>이런식으로 각각 의미에 맞는 태그를 사용하는 것이다 흔한 말로 <code>div 떡칠</code> 을 하지않고 분명한 의미를 가진 태그들을 알맞게 사용하는 것이 중요하다는 것</p>\n<p>그리고 단순히 <code>SEO</code> 와 같은 성능 측면에서의 기대값이 존재하기 때문에 시멘틱 마크업을 해야한다가 아니라</p>\n<p><code>웹 접근성</code> 을 위해서도 필요한 작업이다. 웹 접근성은 장애인이나 노인 분들이 비장애인과 같이 웹 사이트에 접근하여 이해할 수 있도록 하는 것을 의미하는데, </p>\n<p>이때 스크린 리더라는 프로그램을 사용하게 된다. 이 때에도 시멘틱 태그를 사용하는 것이 스크린 리더의 활용에도 긍정적인 영향을 주기 때문에 </p>\n<p>본인이 웹 개발자라면 다양한 사용자 층에게 얼마나<code>포용적</code> 인 웹을 개발하였는지 보여주는 지표가 될 수 있다고 생각한다.</p>\n<h2 id=\"코드예시\">코드예시</h2>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/213a0f11-af28-4faf-be70-c9d4337a4563/image.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/3448e49f-a02a-4550-8cf6-a29eea012acd/image.png\" alt=\"\"></p>\n<p>만약 첫 번째 사진 처럼 모든 태그들이 div로 되어있다면 직관적으로 코드의 구조를 알아보기가 매우 힘들다.</p>\n<p>반면에 두 번째 사진처럼 시맨틱 태그들을 사용하였을 경우 확실히 코드가 구조적으로 명확해보이고 유지보수 측면에서도 장점을 가질 수 있다.</p>\n<blockquote>\n<p>웹 접근성과 SEO는 당연히..</p>\n</blockquote>\n<h2 id=\"시맨틱-마크업과-seo의-구체적인-영향\">시맨틱 마크업과 SEO의 구체적인 영향</h2>\n<ol>\n<li>시맨틱 태그를 사용하면 각 요소의 의미가 명확해져, 검색 엔진은 해당 페이지의 구조와 내용을 당연히 쉽게 파악할 수 있게 된다 </li>\n</ol>\n<p>구체적으로는 검색엔진이 웹사이트를 <code>크롤링</code> 할 때, SEO 요소를 평가해서 페이지의 <code>랭킹</code>을 결정하고 그것이 검색결과 상단 , 하단에 표시 되는 기준 중 하나가 된다.</p>\n<h4 id=\"검색-엔진이-페이지를-평가하는-과정\">검색 엔진이 페이지를 평가하는 과정:</h4>\n<ol>\n<li><p>크롤링 : 웹 페이지를 자동으로 탐색하고 분석하는 단계 이 과정에서 페이지의 컨텐츠 태그, 링크 구조 등을 수집함</p>\n</li>\n<li><p>색인 : 크롤링한 데이터를 바탕으로 각 페이지의 정보를 색인에 저장한다. 이때 페이지의 주제와 관련된 키워드, 메타 데이터, 콘텐츠 풍질 등을 바탕으로 페이지를 분류</p>\n</li>\n</ol>\n<blockquote>\n<p>색인 : 검색엔진의 데이터베이스</p>\n</blockquote>\n<ol start=\"3\">\n<li>랭킹 : 사용자가 특정 키워드로 검색했을 때, 검색엔진은 색인된 페이지들을 랭킹 알고리즘을 통해 순서를 정함 이 가정에서 <code>SEO</code> 요소들이 중요한 역할을 함 </li>\n</ol>\n<p>즉, 색인된 데이터 베이스에서 입력한 검색 쿼리와 가장 관련서이 높은 페이지를 찾아내서 보여주는 것</p>\n<pre><code class=\"language-css\">검색 엔진이 SEO 평가 시 고려하는 요소\n시맨틱 마크업, 메타 태그, 모바일 친화성, 키워드 최적화 ... 등등 \n</code></pre>\n<p>예를 들면 <code>&lt;article&gt;</code> 태그는 독립적인 콘텐츠 블록임을 나타내고, <code>&lt;h1&gt;</code> 은 주요 제목이라는 정보를 전달한다. 검색 엔진은 이 정보들을 기반으로 페이지의 주제와 중요성을 파악해 순위를 매긴다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/855b089b-77b8-414f-aa0b-ba332c8d3a4e/image.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>브라우저 개발자 도구에서 구조 가시성 증가 : 시맨틱 마크업을 사용하면 브라우저의 개발자 도구에서 HTML 요소의 의미와 구조를 쉽게 파악할 수 있음 즉, 디버깅과 유지보수를 간소화 할 수 있다는 것.</li>\n</ol>\n",
    "pubDate": "Thu, 26 Sep 2024 06:57:21 GMT",
    "thumbnail": null
  }
]