[
  {
    "title": "Confeti Sentry 도입기",
    "link": "https://velog.io/@gawgjiug/Confeti-Sentry-%EB%8F%84%EC%9E%85%EA%B8%B0",
    "description": "<p>프론트엔드 개발에서 오류는 크게 데이터(API) 영역과 화면(Layout) 영역에서 발생하는 오류, 그리고 예측할 수 없는 갑작스러운 네트워크 이슈나 특정 브라우저, 운영 체제, 모바일 기기에서 발생할 수 있는 오류로 나눌 수 있습니다.</p>\n<p>API와 화면 영역에서 발생하는 오류는 개발 과정에서 충분히 예방하거나 디버깅을 통해 해결할 수 있으며, QA 과정에서도 재현이 가능하기 때문에 배포 전에 문제를 해결하는 것이 가능합니다. </p>\n<p>그러나 앞서 언급한 네트워크 이슈, 운영 체제, 브라우저, 모바일 기기에서 발생하는 오류, 심지어는 크롬의 정책 변경이나 Safari의 버전 차이와 같은 &#39;예측 불가능한 에러&#39;는 사전에 예방하기가 매우 어렵습니다.</p>\n<p>이러한 상황에서 Sentry는 클라이언트에서 발생하는 오류를 효과적으로 트래킹하고 모니터링할 수 있도록 도와주는 유용한 도구입니다. Sentry는 에러 로그에 대한 상세한 정보를 제공하며, 다양한 통계와 성능 분석 기능을 통해 개발자들이 문제를 신속하게 파악하고 해결할 수 있도록 지원합니다. 또한, 알림 설정 기능을 통해 실시간으로 오류를 감지하고 대응할 수 있는 장점을 제공합니다.</p>\n<p>Confeti에서는 이러한 &#39;예측 불가능한 에러&#39;를 효과적으로 파악하고 트래킹하기 위해 Sentry를 도입하였습니다.</p>\n<h3 id=\"configure\">Configure</h3>\n<pre><code class=\"language-typescript\">  Sentry.init({\n    dsn: import.meta.env.VITE_SENTRY_DSN,\n    tracePropagationTargets: [&#39;localhost&#39;, /^https:\\/\\/confeti\\.co\\.kr/],\n    tracesSampleRate: 1.0,\n    normalizeDepth: 6,\n  });\n  Sentry.addIntegration(Sentry.browserTracingIntegration());</code></pre>\n<ul>\n<li><code>dsn: import.meta.env.VITE_SENTRY_DSN</code> </li>\n</ul>\n<p>Sentry 프로젝트의 DSN 값을 설정하는 부분을 말합니다. DSN은 Sentry 프로젝트를 식별하는 고유한 URL입니다 쉽게 얘기하면 Sentry 서버로 오류 및 성능 데이터를 전송하는 주소인 것. </p>\n<ul>\n<li><code>tracePropagationTargets: [&#39;localhost&#39;, /^https:\\/\\/confeti\\.co\\.kr/]</code></li>\n</ul>\n<p>분산 추적 데이터를 전파할 대상을 지정하는 것입니다 로컬호스트와 콘페티 배포 도메인 2가지를 설정했습니다.</p>\n<blockquote>\n<p>분산 추적이란?\n분산 추적은 여러 개의 서비스나 시스템에서 하나의 요청이 어떻게 흐르는지 추적하는 기법을 말합니다. </p>\n</blockquote>\n<p>예를 들면 사용자가 버튼을 클릭했을 때 FE-&gt; BE -&gt; DB 까지 모든 요청 흐름을 추적할 수 있도록 하는 것입니다. 분산 추적 없이 디버깅을 할 경우에는 어떤 시점에서 요청이 느려지는지, 오류가 발생하는지 확인하기 어렵기 때문에 Sentry 는 <code>Trace ID</code> 를 기반으로 요청 흐름을 모두 기록해서 병목 지점을 파악할 수 있도록 도와줍니다.</p>\n<ul>\n<li><code>tracesSampleRate: 1.0</code> 트랜잭션을 왜 추적해야 할까?\n트랜잭션이 여러 단계로 이루어지면, 어디서 문제가 발생하는지 추적하기 어려워.\n👉 Sentry의 트랜잭션 추적 기능을 사용하면, 트랜잭션이 시작되고 종료될 때까지의 흐름을 기록해서 성능 분석과 에러 디버깅을 쉽게 할 수 있어!</li>\n</ul>\n<p>성능 데이터를 샘플링하는 비율을 설정합니다 1.0 으로 설정해두었기 때문에 모든 트랜잭션을 추적하는 것입니다.</p>\n<blockquote>\n<p>트랜잭션(Transaction) 이란?\n트랜 잭션은 하나의 작업 단위를 의미합니다. \n1️⃣ 프론트엔드에서 &quot;결제하기&quot; 버튼 클릭\n2️⃣ 백엔드에서 결제 요청을 처리\n3️⃣ 결제 서비스(Stripe 등)에서 승인 요청\n4️⃣ 데이터베이스에 주문 정보를 저장\n5️⃣ 사용자에게 &quot;결제가 완료되었습니다&quot; 메시지 표시\n이 모든 과정이 하나의 트랜잭션이라고 볼 수 있습니다.</p>\n</blockquote>\n<pre><code>Transaction: 주문 생성 (/create-order)\n   ├── ① Frontend 요청 (100ms)\n   ├── ② Backend API 호출 (200ms)\n   ├── ③ Payment API 호출 (1.5초 ❌ 실패)\n   ├── ④ Database 저장 (50ms, 취소됨)\n   └── ⑤ 응답 반환 (전체 1.85초)</code></pre><p>이런식으로 트랜잭션을 추적하면 전체 흐름에서 어떤 부분이 느리고, 어디서 문제가 발생하는지 알 수 있습니다.</p>\n<blockquote>\n<p>tracesSampleRate을 줄이면 어떻게 될까?\n예를 들어 tracesSampleRate를 0.5(50%) 로 줄였다고 한다면 같은 주문 생성 요청 10개 중 랜덤으로 선택된 5개만 Sentry 내에 기록되는 것입니다. </p>\n</blockquote>\n<ul>\n<li><code>normalizeDepth: 6</code></li>\n</ul>\n<p>Sentry 가 객체 데이터를 로깅할 때 객체의 중첩된 깊이를 몇 단계까지 기록할지를 설정하는 코드입니다. </p>\n<blockquote>\n<p>로깅 되는 객체 데이터란?\n에러 발생 시 Sentry가 수집하는 다양한 정보(객체 형태) 를 의미합니다.\n1️⃣ 오류 메시지\n2️⃣ 에러 발생 위치 (파일, 함수, 줄 번호 등)\n3️⃣ HTTP 요청 정보 (파라미터, 헤더, 응답 등)\n4️⃣ 유저 정보 (로그인된 사용자 ID, 이메일 등)\n5️⃣ 상태(State) 정보 (애플리케이션 내부 변수, 객체 데이터 등)</p>\n</blockquote>\n<p>자칫 객체를 너무 깊게 중첩하게 되면 로깅할 데이터가 그만큼 많아지는 것이기에 당연히 성능에 무리가 갈 수 있습니다.</p>\n<p>✅ normalizeDepth: 2 (2단계까지만 로깅)</p>\n<pre><code>{\n  &quot;user&quot;: {\n    &quot;id&quot;: 123,\n    &quot;name&quot;: &quot;Alice&quot;,\n    &quot;preferences&quot;: {\n      &quot;theme&quot;: &quot;dark&quot;,\n      &quot;notifications&quot;: &quot;[Object]&quot;\n    }\n  }\n}</code></pre><ul>\n<li>✅ normalizeDepth: 4 (4단계까지 로깅)</li>\n</ul>\n<pre><code>{\n  &quot;user&quot;: {\n    &quot;id&quot;: 123,\n    &quot;name&quot;: &quot;Alice&quot;,\n    &quot;preferences&quot;: {\n      &quot;theme&quot;: &quot;dark&quot;,\n      &quot;notifications&quot;: {\n        &quot;email&quot;: true,\n        &quot;sms&quot;: false\n      }\n    }\n  }\n}</code></pre><h3 id=\"scope\">Scope</h3>\n<p>Sentry 는 scope 단위로 이벤트 데이터를 관리합니다. 이벤트가 전송되면 해당 이벤트의 데이터를 현재 scope 의 추가정보와 병합합니다. </p>\n<p>여기서 Sentry의 Scope는 에러 및 트랜잭션 이벤트와 관련된 추가 정보를 저장하는 <code>컨텍스트</code> 를 말합니다. Sentry는 에러(이벤트)를 전송할 때 현재 Scope에 저장된 정보를 자동으로 병합해서 보낼 수 있습니다. </p>\n<p>추가적으로 Sentry 에서의 scope는 <code>configureScope</code> 와 <code>withScope</code> 두 가지로 나누어 설정할 수 있습니다.</p>\n<p>configureScope는 글로벌 scope와 비슷한 맥락으로 현재 범위 내에서 데이터를 재구성하는데 사용합니다. 이벤트 전송에 있어서 공통적으로 사용되는 정보가 있다면 이 설정을 사용할 수 있습니다.</p>\n<p><code>withScope</code> 설정은 로컬 scope로 한 번의 범위 내에서 데이터를 재구성할 때 사용합니다. 이 scope를 사용하면 기본 Scope는 유지하고, 특정 이벤트에만 <code>추가</code> 정보를 설정할 수 있고, Scope가 블록을 벗어나면 자동으로 <code>Rollback</code> 합니다.</p>\n<p>따라서 응답 값을 받고, 에러 처리는 하는 특정 이벤트에만 태그, 유저 정보등을 추가하여 트래킹하고싶었기 때문에 다음과 같은 코드를 작성하였습니다.</p>\n<pre><code class=\"language-typescript\">26 to +33\n  Sentry.withScope((scope) =&gt; {\n    scope.setLevel(&#39;error&#39;);\n    scope.setTag(&#39;error_type&#39;, &#39;api_error&#39;);\n    scope.setTag(&#39;API URL&#39;, config?.url || &#39;unknown&#39;);\n    scope.setTag(&#39;HTTP Method&#39;, config?.method || &#39;unknown&#39;);\n    scope.setTag(&#39;Status Code&#39;, status.toString());\n    scope.captureMessage(`[API 오류] ${window.location.href}`);\n  });</code></pre>\n<p>즉 , <code>withScope</code> 를 사용하면 Scope가 현재 실행되는 코드 블록 내에서만 유지되도록 설정할 수 있습니다. 추가적으로 현재 범위의 복제본이 생성되는데, <code>withScope</code>를 호출하면 현재 설정된 Scope의 복사본을 만들고 여기에 추가적인 정보를 더할 수 있습니다.</p>\n<pre><code class=\"language-typescript\">Sentry.configureScope((scope) =&gt; {\n  scope.setTag(&quot;globalTag&quot;, &quot;alwaysIncluded&quot;);\n});\n\nSentry.withScope((scope) =&gt; {\n  scope.setTag(&quot;localTag&quot;, &quot;onlyForThisError&quot;);\n  Sentry.captureException(new Error(&quot;로컬 오류!&quot;));\n});</code></pre>\n<p>✅ &quot;로컬 오류!&quot;에는 &quot;globalTag&quot;: &quot;alwaysIncluded&quot;와 &quot;localTag&quot;: &quot;onlyForThisError&quot;가 함께 기록됩니다</p>\n<p>✅ 하지만 &quot;globalTag&quot;: &quot;alwaysIncluded&quot;는 글로벌 Scope라 이후에도 유지되지만, &quot;localTag&quot;: &quot;onlyForThisError&quot;는 이 오류에만 적용됩니다</p>\n<p>이렇듯 <code>withScope</code> 를 사용하면 특정 오류에만 필요한 정보를 추가하고 글로벌 Scope를 오염시키지 않을 수 있습니다.</p>\n<h3 id=\"cutomized-tags\">Cutomized Tags</h3>\n<p><code>tag</code> 는 키와 값이 쌍으로 이루어진 Sentry의 강력한 기능 중 하나의 문자열을 말합니다. tag의 일반적인 용도로는 호스트 네임, 플랫폼 버전, OS 버전, 사용자 언어 등이 존재합니다. <code>tag</code> 는 인덱싱 되는 특성을 가지고 있기 때문에 관련한 이벤트에 빠르게 접근할 수 있고, 이슈 검색이나 트래킹을 신속하게 만들어 주기도 합니다.</p>\n<blockquote>\n<p>인덱싱?</p>\n</blockquote>\n",
    "pubDate": "Sun, 02 Mar 2025 17:54:09 GMT",
    "thumbnail": null
  },
  {
    "title": "Axios 에러 인터셉터와 클라이언트 에러처리",
    "link": "https://velog.io/@gawgjiug/Axios-%EC%97%90%EB%9F%AC-%EC%9D%B8%ED%84%B0%EC%85%89%ED%84%B0%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%97%90%EB%9F%AC%EC%B2%98%EB%A6%AC",
    "description": "<p>앱잼을 진행하면서 에러 인터셉터를 설정하고 API 요청 유틸 함수를 세팅하는 <code>task</code> 를 맡게 되었다. 초기에는 단순히 axios <code>interceptors</code> API 요청에 대해 에러가 발생한다면, 사전에 서버와 합의된 <code>status code</code> 를 통해 에러를 구분할 수 있도록하고,</p>\n<p>해당 <code>code</code>와 <code>message</code> 를 유틸 함수의 인자로 넘겨 에러를 핸들링하는 로직을 작성하려 했으나, 예상했던 에러인지, 예상하지 못했던 에러인지를 파악하기 위해 <code>error code</code> 를 조금 더 세분화하고, 커스텀 하고자 하는 마음이 생겼다.</p>\n<p>예를 들면 같은 <code>401</code> 에러이지만, 유효하지 않은 토큰인지 혹은 만료된 토큰인지를 세분화 하여 개발 생산성을 향상시키고 싶었다.</p>\n<pre><code class=\"language-tsx\">export const HTTP_STATUS_CODE = {\n  SUCCESS: 200,\n  CREATED: 201,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  NOT_FOUND: 404,\n  CONFLICT: 409,\n  INTERNAL_SERVER_ERROR: 500,\n};\n</code></pre>\n<p>더 구체적으로 작성할 수도 있었지만, 짧은 앱잼 기간 동안은 현재 서버에서 사용되는 HTTP 상태 코드를 위와같이 정의해놓고 코드레벨에서 <code>=== 500</code> 대신 <code>=HTTP_STATUS_CODE.INTERNAL_SERVER_ERROR</code>를 사용하면 코드 가독성이 향상된다 판단하였다.</p>\n<h3 id=\"error-object\">Error Object</h3>\n<p>일반적으로 에러가 발생했을 시 거의 대부분의 경우에는 에러 객체 <code>Error</code> 를 반환하게 된다. 하지만 추후에 추가될 에러바운더리에서 해당 객체를 <code>catch</code> 한다면 동일한 Error 객체로 부터 어떠한 정보들을 얻을 수 있는지 생각해볼 수 있다.</p>\n<p>대표적으로는 <code>message</code> <code>name</code> <code>stack</code> <code>cause</code> 등이 존재하고, 더 많은 정보들이 존재하기 때문에 디버깅을 시도할 때 개발자 입장에서 생산성이 저하될 수 있다.</p>\n<p>따라서 에러 객체를 <code>커스텀</code> 하기로 하고</p>\n<pre><code class=\"language-tsx\">import { HTTP_STATUS_CODE } from &#39;@shared/constants/api&#39;;\n\n/** HTTP 통신 시 발생하는 API Error를 별도의 객체로 나타내기 위한 에러 객체입니다. */\nexport class HTTPError extends Error {\n  statusCode: number;\n  code?: number;\n\n  constructor(statusCode: number, message?: string, code?: number) {\n    super(message);\n    let name = &#39;HTTPError&#39;;\n\n    switch (statusCode) {\n      case HTTP_STATUS_CODE.BAD_REQUEST: {\n        name += &#39;: BAD_REQUESET&#39;;\n        break;\n      }\n      case HTTP_STATUS_CODE.UNAUTHORIZED: {\n        name += &#39;: UNAUTHORIZED&#39;;\n        break;\n      }\n      case HTTP_STATUS_CODE.NOT_FOUND: {\n        name += &#39;: NOT_FOUND&#39;;\n        break;\n      }\n\n      case HTTP_STATUS_CODE.INTERNAL_SERVER_ERROR: {\n        name += &#39;: INTERNAL_SERVER_ERROR&#39;;\n        break;\n      }\n    }\n\n    this.name = name;\n    this.statusCode = statusCode;\n    this.code = code;\n  }\n}\n</code></pre>\n<p>위와 같은 코드를 작성하였다. 해당 파일은 <code>shared</code> 내에서 상태 코드별 처리를 분리하는 역할을 하는데, <code>HTTPError</code>  클래스를 상속하거나 특정 상태 코드에 맞게 새로운 메시지를 추가하는 등 커스텀에 용이하기 때문에 이런 방식을 사용하였다.</p>\n<p>뿐만 아니라 중앙에서 에러 처리 로직을 관리할 수 있다는 장점도 존재하고, <code>상태코드</code> <code>에러코드</code> 와 같은 추가적인 정보들을 핸들링 하기 위해 클래스 형태로 만들고 <code>Error</code> 클래스를 확장하였다.</p>\n<p>그렇다면 <code>HTTPError</code> 객체는 어느 시점에 적용해야 가장 알맞을까?? <code>HTTPError</code> 객체는 API 요청 또는 응답 처리 과정에서 발생하는 오류를 다루기 위해 설계되었고, 그렇다면 <code>axios</code>의 인터셉터를 활용하는 시점이 커스텀 에러 객체를 적용하기에 가장 알맞은 시점이라고 판단하였다.</p>\n<p>인터셉터는 HTTP 요청 또는 응답이 이루어지기 전후에 코드 실행을 가로챌 수 있기 때문에, API 오류를 전역적으로 처리하고 이를 커스텀 에러 객체로 통일하는데에 유용하기 때문이다.</p>\n<pre><code class=\"language-tsx\">export const handleAPIError = (error: AxiosError&lt;ErrorResponse&gt;) =&gt; {\n  // 응답이 없는 경우, 원래의 오류를 그대로 던짐\n  if (!error.response) throw error;\n\n  const { data, status } = error.response;\n\n  // 서버 에러 (500 이상)\n  if (status &gt;= HTTP_STATUS_CODE.INTERNAL_SERVER_ERROR) {\n    throw new HTTPError(HTTP_STATUS_CODE.INTERNAL_SERVER_ERROR, data.message, data.code);\n  }\n\n  // 그 외의 에러 (예: 클라이언트 오류 400대)\n  throw new HTTPError(status, data.message, data.code);\n};\n</code></pre>\n<p>이 코드에서 <code>500</code> 코드 이상의 서버에러에 대한 로직이 존재하는 이유는 <code>명확한 에러 관리</code> 를 위함입니다. 500 이상 서버 오류는 일반적으로 시스템 문제에 해당하므로, 이를 HTTPError 로 처리하고 중앙에서 이를 관리함으로써 예상할 수 있는 에러에 대한 명확한 로직을 마련할 수 있기 때문이다.</p>\n<p>예를 들면 서버가 다운되었거나, DB 연결에 문제가 있을 때 <code>HTTPError</code> 객체를 던짐으로써 문제를 효율적으로 추적할 수 있다고 생각하였다.</p>\n<p>반대로 상태 코드 500 이하의 오류들은 클라이언트 측 문제 또는 네트워크 연결 문제를 의미하기 때문에 클라이언트의 잘못된 요청, 잘못된 인자값 입력등 <code>예상할 수 없는 경우</code> 에 발생할 수 있다.</p>\n<h3 id=\"모듈-확장\">모듈 확장</h3>\n<pre><code class=\"language-tsx\">import { AxiosError } from &#39;axios&#39;;\n\ndeclare module &#39;@tanstack/react-query&#39; {\n  interface Register {\n    defaultError: AxiosError;\n  }\n}\n\n/**\n * Query 에서 발생하는 기본적인 에러를 AxiosError 타입으로 설정함\n */\n</code></pre>\n<p>위와 같은 모듈 확장 코드를 추가하여 <code>React Query</code>에서 발생하는 기본적인 에러를 <code>AxiosError</code> 타입으로 설정한 것의 장점은 타입 안정성과 일관성 있는 에러 처리에 있다. 아래와 같이 구체적인 장점을 설명할 수 있는데,</p>\n<h3 id=\"타입-안정성-보장\"><code>타입 안정성 보장</code></h3>\n<p>React Query는 기본적으로 Error 객체를 에러 타입으로 사용한다. 하지만, 실제로 Axios를 사용하여 HTTP 요청을 보내면, 반환되는 에러는 AxiosError 객체입니다. <code>AxiosError</code> 는 Error를 상속하고, HTTP 요청과 관련된 추가적인 정보(예: 응답 데이터, 상태 코드 등)를 포함하므로, 이를 정확히 다루기 위해 AxiosError 타입을 설정하는 것이 중요하다</p>\n<p><code>AxiosError</code> 로 타입을 명시적으로 설정하면, 에러 객체에 대한 추가적인 정보(예: response, status, code, config 등)에 안전하게 접근할 수 있다. 타입이 <code>AxiosError</code>로 확정되기 때문에, 코드에서 해당 속성들에 타입 오류 없이 접근할 수 있어 코드의 안정성이 높아지는 장점이 있다.</p>\n<h3 id=\"일관성-있는-에러-처리\"><code>일관성 있는 에러 처리</code></h3>\n<p>여러 곳에서 Axios를 사용한 API 요청을 처리할 때, <code>AxiosError</code> 객체를 일관되게 다룰 수 있습니다. <code>React Query</code> 에서 발생하는 에러를 <code>AxiosError</code> 로 지정함으로써, 다른 API 요청에서 발생하는 에러를 처리할 때도 동일한 방식으로 접근할 수 있다.</p>\n<h3 id=\"에러-핸들링-로직-통합\"><code>에러 핸들링 로직 통합</code></h3>\n<p><code>AxiosError</code> 타입을 사용함으로써, 여러 Axios 요청에서 발생하는 에러를 통합적으로 처리할 수 있다. 예를 들어, AxiosError가 제공하는 response와 같은 속성을 활용하여 에러 메시지나 상태 코드에 따라 적절한 사용자 피드백을 주는 로직을 통합할 수 있다.</p>\n<p><code>React Query</code>의 useQuery나 useMutation 훅에서 발생하는 에러가 AxiosError로 통일되면, 에러 처리 로직을 한 곳에서 모듈화하고 재사용할 수 있다. 예를 들면, <code>useQuery</code>나 <code>useMutation</code> 에서 발생한 오류를 공통의 에러 핸들링 로직으로 처리함으로써 중복된 코드 작성을 방지할 수 있다.</p>\n<hr>\n<p><a href=\"https://github.com/SOPT-all/35-APPJAM-WEB-CONFETI/pull/144\">https://github.com/SOPT-all/35-APPJAM-WEB-CONFETI/pull/144</a></p>\n",
    "pubDate": "Fri, 31 Jan 2025 18:15:49 GMT",
    "thumbnail": null
  },
  {
    "title": "useRef",
    "link": "https://velog.io/@gawgjiug/useRef-btnpnh62",
    "description": "<h2 id=\"useref\">useRef</h2>\n<p>렌더링과는 별개로 변수를 사용하거나 DOM 요소에 접근할 때 사용되는 기능이다.</p>\n<p>useState 의 경우 값을 바꿀 때 화면도 렌더링 되지만, useRef는 렌더링과 관계없이 변경 가능한 값들을 가질 수 있다.</p>\n<p>=&gt; Ref는 State와 비슷하게 어떠한 값을 저장해두는 저장 공간으로 활용된다.</p>\n<h3 id=\"그래서-useref는-어떤-상황에서-활용하면-좋을까\">그래서 useRef는 어떤 상황에서 활용하면 좋을까??</h3>\n<ol>\n<li>DOM 요소에 접근할 때</li>\n</ol>\n<p>useRef는 HTML 요소에 직접 접근할 때 유용하게 사용될 수 있다. 예를 들자면 특정 input 에 포커스를 설정하거나, 스크롤 동작을 제어할 때 사용된다.</p>\n<pre><code class=\"language-javascript\">import React, { useRef } from &quot;react&quot;;\n\nfunction InputFocus() {\n  const inputRef = useRef(null);\n\n  const focusInput = () =&gt; {\n    inputRef.current.focus();\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;input ref={inputRef} type=&quot;text&quot; /&gt;\n      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n<p>이 코드는 useRef를 사용해서 input 요소의 참조를 생성하고, 버튼 클릭 시 해당 input 요소에 포커스를 맞추는 기능을 한다. 그래서 왜 <code>useRef</code> 가 DOM 요소에 직접적인 조작이 필요한 경우에 유용하게 사용될 수 있느냐??</p>\n<p>왜냐하면 useRef를 통해 생성된 <code>참조 객체</code> 를 통해 DOM 요소에 직접 접근할 수 있기 때문이다.</p>\n<p>참조객체는 무엇이냐? </p>\n<p><code>참조 객체</code> 는 React 에서 useRef 훅을 사용해서 생성된 객체를 말한다. 이 객체는 알다싶이 렌더링 사이클과 독립적으로 유지되는 변경 가능한 값을 저장할 때 사용된다.</p>\n<h3 id=\"참조-객체의-주요-특징\">참조 객체의 주요 특징</h3>\n<ol>\n<li><p><code>current</code> 프로퍼티를 통해 값에 접근</p>\n<ul>\n<li><code>useRef</code> 로 생성된 객체는 {current : ...} 형태를 가지고 있기에 <code>current</code> 프로퍼티에 저장된 값에 접근 하거나 변경할 수 있다.</li>\n</ul>\n</li>\n<li><p>React의 렌더링 사이클과 독립적</p>\n</li>\n</ol>\n<hr>\n<p>useRef는 이러한 특징들 때문에 DOM 조작에 유용한 것이다 특정 DOM 요소를 직접 조작할 때 렌더링 흐름과 충돌하지 않고도 필요한 조작을 수행할 수 있게끔, 안전하고 간단하게 DOM 에 접근할 수 있도록 해준다.</p>\n<h3 id=\"ref-활용의-모범사례\">Ref 활용의 모범사례</h3>\n<ul>\n<li><p>필요한 경우에만 사용 : Ref 는 직접적인 DOM 접근이 필요할 때 사용해야 한다. 포커스 설정, 텍스트 선택 , 미디어 재생제어와 같이 <code>선언적인</code> 방식으로 해결할 수 없는 작업에 사용한다.</p>\n</li>\n<li><p>컴포넌트 내부에서만 사용 : Ref는 컴포넌트 내부에서만 사용하고 외부로 노출시키지 않는다. 컴포넌트의 내부 구현을 외부로 유출시키면 컴포넌트의 재사용성과 유지보수성이 떨어지기 때문</p>\n</li>\n<li><p>상태 업데이트에는 사용하지 않기 : Ref를 사용해 상태 업데이트와 같은 리액트의 데이터 흐름을 우회하는 것은 피해야한다.</p>\n</li>\n</ul>\n<h3 id=\"ref-활용-주의-사항\">Ref 활용 주의 사항</h3>\n<ul>\n<li><p>Ref 남용 방지 : 모든 상호 작용이나 DOM 조작에 Ref 를 사용하는 것은 <code>지양</code> 해야 한다. 리액트의 선언적 UI 구성 방식과 잘 어우러지지 않으며 애플리케이션의 복잡성을 높일 수 있음.</p>\n</li>\n<li><p>함수형 컴포넌트에서의 useRef 우선 사용 : 클래스 컴포넌트에서는 createRef 를, 함수형 컴포넌트에서는 useRef를 사용하는 것이 권장됩니다. 함수형 컴포넌트와 훅을 사용하는 현대 리액트 개발 패러다임에 더 잘 부합합니다.</p>\n</li>\n<li><p>동적 Ref 사용 시 주의 : 여러 요소에 대한 Ref를 동적으로 생성하고 관리해야 할 때 문자열 대신 함수를 사용하거나 Map 객체를 활용하는 등의 방법으로 관리하는 것이 좋다.</p>\n</li>\n</ul>\n<h2 id=\"다시-한번-더-왜\">다시 한번 더 왜?</h2>\n<blockquote>\n<p>필요한 경우에만 사용 : Ref 는 직접적인 DOM 접근이 필요할 때 사용해야 한다. 포커스 설정, 텍스트 선택 , 미디어 재생제어와 같이 <code>선언적인</code> 방식으로 해결할 수 없는 작업에 사용한다.</p>\n</blockquote>\n<p>useRef를 사용하면 DOM에 직접 접근하므로 React의 선언적 흐름을 우회하는 것. 여기서 <code>선언적</code> 이란?? 리액트가 상태와 props를 통해 UI를 자동으로 관리하는 것을 말함</p>\n<blockquote>\n<p>컴포넌트 내부에서만 사용</p>\n</blockquote>\n<p>Ref는 컴포넌트의 구현 <code>세부 사항</code> 을 드러낸다. 이를 외부로 노출하면 컴포넌트가 다른 컴포넌트와 강하게 결합되어 재사용성이 떨어진다는 것</p>\n<pre><code class=\"language-javascript\">function MyComponent() {\n  const inputRef = useRef();\n\n  // 내부에서 Ref를 사용\n  const focusInput = () =&gt; inputRef.current.focus();\n\n  return &lt;input ref={inputRef} /&gt;;\n}\n</code></pre>\n<p>예를 들면 위 코드에서는 Ref가 컴포넌트 내부에만 존재하므로 외부에서 해당 <code>input</code> 을 제어할 수 없게끔 설계 되어있다. 만약 Ref 를 외부로 노출한다면 외부 컴포넌트(코드) 가 해당 Ref를 남용할 가능성이 있음</p>\n<blockquote>\n<p>상태 업데이트에는 사용하지 않기</p>\n</blockquote>\n<p>Ref 를 통해 상태를 관리하려 하면 React의 <code>렌더링 프로세스</code> 와 동기화 되지 않는 데이터가 발생할 수 있음 즉, 상태 변화가 React의 렌더링 트리거를 동반하지 않으므로 UI가 예상과 다르게 작동할 수 있음.</p>\n<blockquote>\n<p>왜 문자열 Ref는 사용하지 않아야 할까?</p>\n</blockquote>\n<p>React v16 이후, 문자열 Ref는 더 이상 권장되지 않고있다. 이유는 문자열 Ref가 React의 향후 릴리즈에서 제거될 가능성이 있고, 문자열 Ref 는 컴포넌트 사이에서 값을 동적으로 할당하거나 변경하기 어렵기 때문</p>\n",
    "pubDate": "Wed, 11 Dec 2024 03:51:28 GMT",
    "thumbnail": null
  },
  {
    "title": "this?",
    "link": "https://velog.io/@gawgjiug/this",
    "description": "<h3 id=\"this란\">this란??</h3>\n<p>this는 기본적으로 window를 말한다 일반 함수 내에서 혼자 this를 선언하면 그 this는 <code>window</code> 객체를 가르킨다.</p>\n<p>일반 함수가 아니라면?? </p>\n<p>객체 메서드 a 안의 this는 obj를 가리킨다. 왜?? 객체의 메서드를 호출할 때 this를 내부적으로 바꿔주기 때문이다</p>\n<pre><code class=\"language-javascript\">let obj = {\n  a: function () {\n    console.log(this);\n  },\n};\n\nobj.a(); // obj\n</code></pre>\n<p>여기서 바꿔준다는 표현은 호출 방식에 따라서 달라진다는 것을 의미한다. </p>\n<ol>\n<li>obj 객체 내부에서 a 메서드를 찾음. </li>\n<li>메서드가 호출될 때 this를 obj로 바인딩 즉, 자바스크립트가 <code>a</code> 를 실행하는 동안 해당 함수의 실행 컨텍스트에서는 <code>this</code> 는 <code>obj</code> 를 가리킴</li>\n</ol>\n<hr>\n<pre><code class=\"language-javascript\">var a2 = obj.a;\na2(); // window</code></pre>\n<p>반면에 이렇게 코드를 작성하면 a2는 obj.a 를 꺼내온 것이기 때문에 더 이상 obj의 메서드가 아니라고 인식을 한다.</p>\n<p>즉 호출할 때, 호출하는 함수가 객체의 메서드인지, 그냥 함수인지가 중요하다. 자바와는 다르게 JS에서 <code>this</code> 가 가리키는 값은 함수가 호출되는 <code>방식</code> 에 따라 동적으로 결정되는 것</p>\n<p>obj.a() 를 호출할 때, this는 a 메서드를 호출한 객체은 obj를 가리킨다.</p>\n<p>즉, 점(.) 연산자나 대괄호 [] 를 통해 호출하면 해당 객체가 <code>this</code> 로 설정됩니다. 여기서 자바스크립트는 내부적으로 호출 객체를 <code>this</code> 로 바인딩한다</p>\n<pre><code class=\"language-javascript\">let a2 = obj.a; // 메서드를 변수로 복사\na2(); // window (브라우저 환경), undefined (strict 모드)</code></pre>\n<p>a2는 obj.a 의 참조 주소만 복사한 것이다. a2는 독립적인 함수로 취급 되기 때문에 이때 a2() 를 호출하면 메서드 호출이 아니라 일반 함수 호출로 간주된다.</p>\n<h3 id=\"왜-더-이상-obj를-가리키지-않을까\">왜 더 이상 obj를 가리키지 않을까??</h3>\n<p>자바스크립트는 <code>this</code> 를 메서드 정의 시점이 아니라 <strong>호출 시점</strong> 에 결정한다. a2()는 독립적인 함수로 호출되었으므로, this와 obj 와는 무관해짐</p>\n<p>가장 결정적인 것은 <code>호출 방식</code> obj.a() 처럼 객체를 통해 호출하면 this는 해당 객체를 가리킨다. a2() 처럼 독립적인 함수 호출이면, <code>this</code> 는 기본적으로 전역 객체를 가리킴</p>\n<p>여기서 한 가지 예외가 있는데 <code>화살표 함수</code> 이다. 화살표 함수는 <code>this</code> 를 정의된 위치의 상위 스코프에서 상속한다. 호출 방식에 영향을 받지 않으므로 다르게 동작할 수 있음</p>\n<h3 id=\"자바와의-차이\">자바와의 차이</h3>\n<p>Java에서는 this는 인스턴스 자신(self) 을 가리키는 참조변수인데, 자바스크립트 같은 경우 this에 바인딩되는 객체는 한가지로 고정되는 것이 아니라 달라질 수 있다는 점</p>\n<h3 id=\"함수-호출-방식과-this-바인딩\">함수 호출 방식과 this 바인딩</h3>\n<p>기본적으로 this는 전역객체(Global object)에 바인딩된다.</p>\n<p>일반 전역 함수는 물론이고 내부함수의 경우도 this는 외부함수가 아닌 전역 객체에 바인딩된다. 자바스크립트에서는 함수 내부의 또 다른 내부함수는 this를 자동으로 부모함수의 this로 상속받지 않는다.</p>\n<pre><code class=\"language-javascript\">function foo() {\n  console.log(&quot;foo&#39;s this: &quot;,  this);  // window\n  function bar() {\n    console.log(&quot;bar&#39;s this: &quot;, this); // window\n  }\n  bar();\n}\nfoo();</code></pre>\n<p>마찬가지로 콜백 함수의 경우에도 this는 전역객체에 바인딩된다. 콜백 함수는 별도의 컨텍스트에서 실행되기 때문이다</p>\n<p>내부함수의 this가 전역객체를 참조하는 것을 회피하는 방법은 아래와 같은데, </p>\n<p>화살표 함수를 사용하면 된다. 화살표 함수는 <code>this</code> 를 상위 스코프에서 상속받기 때문</p>\n<pre><code class=\"language-javascript\">let obj = {\n  value: 10,\n  method: function () {\n    console.log(this.value); // 10\n\n    const inner = () =&gt; {\n      console.log(this.value); // 10\n    };\n\n    inner();\n  },\n};\n\nobj.method();</code></pre>\n<p>화살표 함수에서는 <code>this</code> 가 동적으로 설정되지 않고 정의된 위치의 <code>this</code> 를 유지한다.</p>\n<p>이외에도 bind,call,apply 등등 으로 회피할 수 있지만 현재는 화살표 함수로 대체하고 있다. 가장 현대적인 방법</p>\n<h3 id=\"결론\">결론</h3>\n<p><code>this</code> 는 자바스크립트에서 함수가 호출되는 방식에 따라 동적으로 바인딩되는 특성을 가진다. 이를 이해하는 것은 객체 지향적인 코드 작성뿐만 아니라 콜백 함수, 내부 함수, 화살표 함수 등 다양한 상황에서 의도한 대로 코드를 동작하게 만드는 데 중요하다.</p>\n<ol>\n<li>기본적으로 전역 객체를 가리킴</li>\n</ol>\n<p>전역 함수에서의 this는 브라우저 환경에서는 window, Node.js 환경에서는 global을 참조한다.</p>\n<ol start=\"2\">\n<li>객체 메서드 호출 시 바인딩</li>\n</ol>\n<p>obj.a()처럼 객체를 통해 호출하면 this는 해당 객체를 참조한다.\n하지만, 메서드를 변수에 할당하거나, 함수로 독립적으로 호출하면 this는 다시 전역 객체를 가리킨다.</p>\n<ol start=\"3\">\n<li>내부 함수에서의 this 문제</li>\n</ol>\n<p>일반 함수 내의 내부 함수에서 this는 상위 함수가 아닌 전역 객체를 가리킨다.\n이를 해결하기 위해 bind, call, apply와 같은 명시적인 바인딩 방법을 사용하거나, 화살표 함수를 활용하여 상위 스코프의 this를 상속받을 수 있다.</p>\n<ol start=\"4\">\n<li>화살표 함수의 특별한 this 처리</li>\n</ol>\n<p>화살표 함수는 호출 방식에 관계없이 상위 스코프의 this를 유지한다. 따라서 객체 메서드나 콜백 함수에서 의도치 않은 this 바인딩 문제를 해결하는 가장 현대적인 방법이다.</p>\n<ol start=\"5\">\n<li>동적 바인딩과 자바와의 차이</li>\n</ol>\n<p>자바의 this는 객체 인스턴스를 고정적으로 가리키는 반면, 자바스크립트의 this는 함수 호출 방식에 따라 달라지므로 더 유연하지만, 예측하기 어렵다는 단점이 있다.</p>\n",
    "pubDate": "Wed, 04 Dec 2024 08:18:45 GMT",
    "thumbnail": null
  },
  {
    "title": "MSW 에 대해서 아시나요?",
    "link": "https://velog.io/@gawgjiug/MSW-%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%84%EC%8B%9C%EB%82%98%EC%9A%94",
    "description": "<p>최근에 데이터를 실제로 fetching 하기 전 <code>퍼블리싱 혹은 Mocking</code> 단계에서는 컴포넌트를 어떻게 설계해야할까? 에 대한 고민을 하다가 <code>MSW</code> 라이브러리에 대해서 알게되어서 글을 작성합니다.</p>\n<p>우선 가장 이상적인 프론트와 백엔드의 작업방식은 API 명세가 모두 나온 이후에 FE 개발자가 작업에 들어가는 것입니다. 하지만 현실적으로 그러기 어려운 상황에서는 MSW(Mock Service Worker)를 활용한 API<code>모킹</code> 전략을 이용할 수 있습니다.</p>\n<p>앞에서 말한대로, <code>API 모킹</code> 은 개발 초기 단계에서 백엔드 서비스가 준비되지 않았을 때 혹은 더 나아가서 통합테스트를 수행할 때 매우 중요한 역할을 합니다.</p>\n<p>왜냐하면 API 모킹을 통해 실제 백엔드 서비스 없이도 프론트엔드 애플리케이션의 동작을 시뮬레이션 할 수 있기 때문입니다.</p>\n<hr>\n<h3 id=\"msw-소개\">MSW 소개</h3>\n<p>리액트 환경에서의 MSW는 브라우저와 <code>Node.js</code> 환경에서 네트워크 요청을 <code>가로채고</code> 모킹할 수 있는 라이브러리입니다.</p>\n<p>정확히는 MSW를 사용하여 실제 네트워크 요청을 가로채고, 개발자가 정의한 응답으로 대체할 수 있는 것인데요 이를 이용하면 실제 백엔드 서버 없이도 API 요청과 응답을 시뮬레이션 할 수 있겠죠?</p>\n<p>그리고 <code>요청 지연</code> 이나 상태 코드 등을 설정할 수 있어서 실제 네트워크 요청과 유사한 환경에서 시뮬레이션을 할 수 있습니다.</p>\n<hr>\n<h3 id=\"msw-작동-방식\">MSW 작동 방식</h3>\n<p>MSW가 브라우저에서 동작하는 방식은 다음과 같습니다. 우선 MSW 라이브러리를 설치하면 브라우저에 Servie Worker 를 등록합니다. 이후에 브라우저에서 이루어지는 실제 네트워크 <code>요청</code> 들을 (fetch 로 보낸 네트워크 요청 등등) Service Worker 가 가로채게 됩니다.</p>\n<p>그리고 이 가로챈 요청을 복사해서 실제 서버가 아니라 클라이언트 사이드에 있는 MSW 라이브러리로 보낸 후에 등록된 핸들러를 통해서 모의 응답을 제공받습니다. 그리고 제공받은 모의응답을 브라우저에게 그대로 전달하게 되는 것입니다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/c30b6a57-354f-4bf1-8358-cd7634b62208/image.png\" alt=\"\"></p>\n<blockquote>\n<p>그래서 Service Worker가 뭔데?</p>\n</blockquote>\n<p>서비스 워커는 브라우저가 백그라운드에서 실행하는 스크립트를 말하고, 웹 서비스와 브라우저 및 네트워크 사이에서 <code>프록시 서버</code> 의 역할을 한다.</p>\n<hr>\n<h3 id=\"사용-방법\">사용 방법</h3>\n<ol>\n<li>설치</li>\n</ol>\n<pre><code>npm install msw --save-dev</code></pre><ol start=\"2\">\n<li>핸들러 정의</li>\n</ol>\n<pre><code class=\"language-javascript\">// src/mocks/handlers.js\nimport { rest } from &#39;msw&#39;; //rest 객체 가져오기 API ㅇ청을 모킹하기 위한 헬퍼 제공\n\nexport const handlers = [\n  rest.get(&#39;/api/user&#39;, (req, res, ctx) =&gt; { //res 응답 , ctx 응답내용 설정\n    return res(\n      ctx.status(200),\n      ctx.json({ id: 1, name: &#39;John Doe&#39; })\n    );\n  }),\n];</code></pre>\n<ol start=\"3\">\n<li>Service Worker 설정</li>\n</ol>\n<pre><code class=\"language-javascript\">// src/mocks/browser.js\nimport { setupWorker } from &#39;msw&#39;;\nimport { handlers } from &#39;./handlers&#39;;\n\nexport const worker = setupWorker(...handlers); //인스턴스 생성 및 요청 핸들러 정의</code></pre>\n<ol start=\"4\">\n<li>Worker 실행 </li>\n</ol>\n<p>어플리케이션이 실행 될 때 워커를 실행하는 코드를 추가</p>\n<pre><code class=\"language-javascript\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport App from &#39;./App&#39;\n\nif (process.env.NODE_ENV === &#39;development&#39;) {\n  const { worker } = require(&#39;./mocks/browser&#39;)\n  worker.start()\n}\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))</code></pre>\n<ol start=\"5\">\n<li>적용 확인</li>\n</ol>\n<pre><code>[MSW] Mocking enabled.</code></pre><p>어플리케이션을 다시 시작하고, 브라우저 콘솔에서 아래와 같은 메세지가 뜨면 모킹이 활성화 된 것이다.</p>\n<p>그리고 이제 클라이언트에서 요청을 보내게 되면</p>\n<pre><code class=\"language-javascript\">fetch(&#39;/api/user&#39;)\n  .then((response) =&gt; response.json())\n  .then((data) =&gt; console.log(data)); // { id: 1, name: &quot;John Doe&quot; }</code></pre>\n<pre><code>{ id: 1, name: &quot;John Doe&quot; }</code></pre><p>이렇게 정상적으로 데이터를 받아볼 수 있다.</p>\n<h3 id=\"마무리\">마무리</h3>\n<p>현재 진행 중인 프로젝트에 MSW를 도입해 개발을 하니깐 굉장히 편리하다고 느꼈기 때문에 공유하고 싶었습니다. 정해진 기간에 백엔드와 프론트엔드가 동시에 개발을 시작하는데 API가 준비되지 않은 상황에서 프론트 개발을 빠르게 할 수 있다는 점이 너무 크게 다가왔었고, </p>\n<p>백엔드 의존도를 많이 줄이고 독립적으로 작업할 수 있어서 오히려 테스트 시간을 더 많이 확보한다거나 리팩토링 기간을 더 길게 잡는다던가 하는 일정 조율이 가능해서 추천드립니다.</p>\n<p>그리고 특히 직접 네트워크 <code>응답 상태</code> 를 조절하면서 내가 원하는 화면 (성공 화면, 로딩 화면, 에러 화면) 을 효율적으로 개발할수 있었고 <code>req</code> 에 에러코드를 전달해서 디버깅도 가능합니다.</p>\n<p><a href=\"https://mswjs.io/\">참고</a></p>\n",
    "pubDate": "Thu, 21 Nov 2024 06:47:41 GMT",
    "thumbnail": null
  },
  {
    "title": "React Query Optimistic Updates",
    "link": "https://velog.io/@gawgjiug/React-Query-Optimistic-Updates",
    "description": "<h3 id=\"낙관적-업데이트\">낙관적 업데이트</h3>\n<p>낙관적 업데이트의 개념은 다음과 같다.</p>\n<ul>\n<li><p>데이터가 <code>실제 서버</code> 에 반영되기 전에 미리 UI에 반영하여 사용자 경험을 향상시키는 기법</p>\n</li>\n<li><p>사용자가 서버 응답을 기다리지 않고도 즉각적인 피드백을 받을 수 있게 해준다.</p>\n</li>\n</ul>\n<p>낙관적 업데이트의 주요 단계는 이렇다.</p>\n<p>우선 업데이트를 수행하기 전에 현재 상태를 저장해야한다. 서버 요청이 실패했을 경우 원래 상태로 롤백하기 위함이다.</p>\n<h4 id=\"어떻게\">어떻게?</h4>\n<p>낙관적 상태 업데이트의 과정은 이렇다. </p>\n<p><code>queryClient.setQueryData</code> 메서드를 사용해서 로컬상태를 즉시 업데이트 한다. </p>\n<ul>\n<li>이 작업 전에 <code>queryClient.cancleQueries</code> 메서드로 해당 쿼리에 대한 모든 활성 쿼리를 취소해줄 수 있다.</li>\n</ul>\n<p>바로 이 작업이 사용자가 변경 사항을 즉시 확인할 수 있도록 하는 것</p>\n<hr>\n<p>그 다음 실제 데이터를 전송한다. 이때 <code>mutate</code> 혹은 <code>mutateAsync</code> 메서드를 사용하는 것</p>\n<p>서버 요청이 성공하면, 서버로부터 받은 최신 데이터를 다시 상태에 반영한다. 이 작업은 <code>onSettled</code> 콜백 함수에서 수행. </p>\n<hr>\n<h3 id=\"예제-코드\">예제 코드</h3>\n<p>코드로 낙관적 업데이트를 알아보면 이렇다</p>\n<pre><code class=\"language-javascript\">import { useMutation, useQueryClient } from &#39;react-query&#39;;\n\nfunction MyComponent() {\n    const queryClient = useQueryClient();\n\n    // Mutation을 설정합니다\n    const { mutate } = useMutation(updateData, {\n        // 1. 낙관적 업데이트: 기존 상태 백업, 즉시 UI에 반영\n        onMutate: async (newData) =&gt; {\n            await queryClient.cancelQueries(&#39;myData&#39;); // 활성 쿼리 취소\n\n            // (1) 기존 상태를 백업\n            const previousData = queryClient.getQueryData(&#39;myData&#39;); // 현재 상태를 백업\n\n            // (2) UI에 즉시 반영\n            queryClient.setQueryData(&#39;myData&#39;, (oldData) =&gt; {\n                return { ...oldData, ...newData }; // 새 데이터를 UI에 반영\n            });\n\n            // (3) 이전 상태 반환 (onError에서 롤백 시 사용)\n            return { previousData }; // 이후의 onError 등에서 복원할 수 있도록 반환\n        },\n\n        // 2. 서버 요청 실패 시 백업한 상태로 롤백\n        onError: (error, newData, context) =&gt; {\n            queryClient.setQueryData(&#39;myData&#39;, context.previousData); // 이전 상태로 복원\n        },\n\n        // 3. 서버 응답 시 최신 데이터로 상태 갱신\n        onSettled: () =&gt; {\n            queryClient.invalidateQueries(&#39;myData&#39;); // 데이터를 다시 가져와 최신 상태로 유지\n        },\n    });\n\n    return (\n        &lt;button onClick={() =&gt; mutate({ key: &#39;value&#39; })}&gt;\n            Update Data\n        &lt;/button&gt;\n    );\n}</code></pre>\n<p>onMutate 함수는 서버에 요청을 보내기 직전에 실행되며, 서버 요청이 실패했을 때는 UI 상태를 복원하는 동작을 수행한다.</p>\n<blockquote>\n<pre><code>       await queryClient.cancelQueries(&#39;myData&#39;); // 활성 쿼리 취소</code></pre></blockquote>\n<p>먼저 활성 쿼리를 취소해주는 작업은 <code>정확성</code> 을 보장하기 위해 존재한다.</p>\n<p>예를 들어 백엔드에서 데이터를 다시 가져오는 쿼리가 활성화 되어있다면, 서버 응답 시에 이전 데이터로 덮어 쓰는 문제가 발생할 수 있다</p>\n<p>더 자세하게는 사용자가 UI 에서 데이터를 업데이트하자마자 백엔드에서 이전 데이터를 불러오는 쿼리가 완료되면 업데이트된 UI가 갑자기 예전 상태로 돌아가 보일 수 있다.</p>\n<hr>\n<h3 id=\"활성-쿼리-취소\">활성 쿼리 취소</h3>\n<p>활성 쿼리 취소가 <code>왜?</code> 필요한지에 대해서 더 자세히 설명해보겠다. </p>\n<p>예를 들어 게시글 페이지에서 댓글 리스트가 표시되고, 각 댓글에는 좋아요 버튼이 존재한다고 가정해보자.</p>\n<p>사용자가 댓글에 좋아요를 누르면 해당 댓글의 좋아요 수가 UI에 즉시 반영되도록 낙관적 업데이트를 적용했다</p>\n<p>동시에 이 페이지에는 일정 주기로 백엔드에서 <code>최신 댓글 데이터를 가져오는 쿼리</code> <code>fetchComment</code> 가 활성화 되어있었는데,</p>\n<p>사용자가 좋아요 버튼을 클릭했을 때 낙관적 업데이트로 즉시 반영된 상태에서, 동시에 <code>fetchComment</code> 쿼리가 백엔드에서 이전의 댓글 리스트 데이터를 받아와 UI를 덮어 써버린다. </p>\n<p>위와 같은 현상을 방지하기 위해서 업데이트를 적용하기 전에 <code>cancleQueries</code> 를 호출해서 <code>fetchComment</code> 쿼리를 일시적으로 취소하는 것.</p>\n",
    "pubDate": "Mon, 11 Nov 2024 14:21:50 GMT",
    "thumbnail": null
  }
]